import { useState, useEffect, useCallback, useRef } from 'react'
import { authCookies } from '../utils/cookies'

interface ChatAvailability {
  isAvailable: boolean
  isLoading: boolean
  error: string | null
  canSend: boolean
  ticketData?: {
    id: string
    title: string
    ticket_number: string
    status: string
    priority: string
    created_by?: {
      name: string
      email: string
    }
    assigned_to?: {
      name: string
      email: string
    }
  }
  chatAccess?: {
    canAccess: boolean
    canSend: boolean
    reason: string
    ticketStatus: string
  }
}

export function useChatAvailability(ticketId: string, pausePolling: boolean = false, isHistoryMode: boolean = false) {
  const [chatAvailability, setChatAvailability] = useState<ChatAvailability>({
    isAvailable: false,
    isLoading: true,
    error: null,
    canSend: false
  })
  const [hasInitialized, setHasInitialized] = useState(false)
  const [shouldPoll, setShouldPoll] = useState(true)
  const [isWaitingForTechnician, setIsWaitingForTechnician] = useState(false)

  const checkChatAvailability = useCallback(async () => {
    try {
      // S√≥ mostrar loading na primeira verifica√ß√£o
      if (!hasInitialized) {
        setChatAvailability(prev => ({ ...prev, isLoading: true, error: null }))
      }
      
      const token = authCookies.getToken()
      if (!token) {
        setChatAvailability({
          isAvailable: false,
          isLoading: false,
          error: 'Token de autentica√ß√£o n√£o encontrado'
        })
        return
      }

      console.log('üîë Token encontrado:', token ? 'Sim' : 'N√£o')
      console.log('üîë Token (primeiros 20 chars):', token ? token.substring(0, 20) + '...' : 'N/A')
      console.log('üé´ Ticket ID:', ticketId)
      console.log('üé´ Ticket ID type:', typeof ticketId)
      
      // Verificar se o token √© v√°lido e obter role
      let userRole = null
      if (token) {
        try {
          const decoded = JSON.parse(atob(token.split('.')[1]))
          userRole = decoded.role || decoded.userRole
          console.log('üë§ Usu√°rio do token:', decoded.userId, 'Role:', userRole)
        } catch (e) {
          console.log('‚ùå Token inv√°lido ou corrompido')
        }
      }

      // Primeiro, buscar informa√ß√µes do ticket para verificar se h√° t√©cnico atribu√≠do
      console.log(`üîç Verificando informa√ß√µes do ticket`)
      
      const ticketResponse = await fetch(`/helpdesk/tickets/${ticketId}`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      })

      console.log(`üìä Status da resposta do ticket: ${ticketResponse.status}`)

      if (!ticketResponse.ok) {
        const errorText = await ticketResponse.text()
        console.log(`‚ùå Erro ao buscar ticket: ${ticketResponse.status} - ${errorText}`)
        throw new Error(`Status ${ticketResponse.status}: ${errorText}`)
      }

      const ticketData = await ticketResponse.json()
      console.log(`‚úÖ Dados do ticket:`, ticketData)
      
      // Verificar se o ticket est√° fechado primeiro
      const isClosed = ['Closed', 'Cancelled', 'Resolved'].includes(ticketData.status)
      console.log('üîí Ticket fechado?', isClosed)
      console.log('üìä Status do ticket:', ticketData.status)
      console.log('üìö Modo hist√≥rico?', isHistoryMode)
      
      if (isClosed && !isHistoryMode) {
        console.log('‚ùå Chat n√£o dispon√≠vel: ticket fechado (modo ativo)')
        setChatAvailability({
          isAvailable: false,
          isLoading: false,
          error: null,
          canSend: false,
          ticketData: {
            id: ticketData.id.toString(),
            title: ticketData.title,
            ticket_number: ticketData.ticket_number,
            status: ticketData.status,
            priority: ticketData.priority,
            created_by: ticketData.creator ? {
              name: ticketData.creator.name,
              email: ticketData.creator.email
            } : undefined,
            assigned_to: (ticketData.assignee || ticketData.assigned_to) ? {
              name: (ticketData.assignee || ticketData.assigned_to).name,
              email: (ticketData.assignee || ticketData.assigned_to).email
            } : undefined
          },
          chatAccess: {
            canAccess: false,
            canSend: false,
            reason: 'Ticket fechado - chat n√£o dispon√≠vel',
            ticketStatus: ticketData.status
          }
        })
        return
      }
      
      if (isClosed && isHistoryMode) {
        console.log('üìö Modo hist√≥rico: permitindo chat em modo leitura para ticket fechado')
        // No modo hist√≥rico, permitir chat em modo leitura mesmo para tickets fechados
        // Mas s√≥ se houver mensagens ou se o usu√°rio tem permiss√£o
      }
      
      // Verificar se h√° t√©cnico atribu√≠do
      const hasAssignee = !!(ticketData.assigned_to || ticketData.assignee)
      console.log('üë§ Tem t√©cnico atribu√≠do?', hasAssignee)
      console.log('üë§ T√©cnico assigned_to:', ticketData.assigned_to)
      console.log('üë§ T√©cnico assignee:', ticketData.assignee)
      console.log('üë§ T√©cnico (qualquer um):', ticketData.assigned_to || ticketData.assignee)

      // Se n√£o h√° t√©cnico atribu√≠do, o chat n√£o est√° dispon√≠vel (exceto no modo hist√≥rico)
      if (!hasAssignee && !isHistoryMode) {
        console.log('‚ùå Chat n√£o dispon√≠vel: nenhum t√©cnico atribu√≠do (modo ativo)')
        setIsWaitingForTechnician(true)
        setChatAvailability({
          isAvailable: false,
          isLoading: false,
          error: null,
          canSend: false,
          ticketData: {
            id: ticketData.id.toString(),
            title: ticketData.title,
            ticket_number: ticketData.ticket_number,
            status: ticketData.status,
            priority: ticketData.priority,
            created_by: ticketData.creator ? {
              name: ticketData.creator.name,
              email: ticketData.creator.email
            } : undefined,
            assigned_to: (ticketData.assignee || ticketData.assigned_to) ? {
              name: (ticketData.assignee || ticketData.assigned_to).name,
              email: (ticketData.assignee || ticketData.assigned_to).email
            } : undefined
          },
          chatAccess: {
            canAccess: false,
            canSend: false,
            reason: 'Aguardando t√©cnico aceitar o chamado',
            ticketStatus: ticketData.status
          }
        })
        return
      }
      
      if (!hasAssignee && isHistoryMode) {
        console.log('üìö Modo hist√≥rico: verificando se h√° mensagens existentes')
        // No modo hist√≥rico, s√≥ permitir se houver mensagens existentes
        // Verificar se existem mensagens para este ticket
        try {
          const messagesResponse = await fetch(`/api/messages/list?ticket_id=${ticketId}&is_history_mode=true`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          })
          
          if (messagesResponse.ok) {
            const messagesData = await messagesResponse.json()
            const hasMessages = messagesData.messages && messagesData.messages.length > 0
            
            if (!hasMessages) {
              console.log('‚ùå Modo hist√≥rico: sem mensagens existentes')
              setChatAvailability({
                isAvailable: false,
                isLoading: false,
                error: null,
                canSend: false,
                ticketData: {
                  id: ticketData.id.toString(),
                  title: ticketData.title,
                  ticket_number: ticketData.ticket_number,
                  status: ticketData.status,
                  priority: ticketData.priority,
                  created_by: ticketData.creator ? {
                    name: ticketData.creator.name,
                    email: ticketData.creator.email
                  } : undefined,
                  assigned_to: (ticketData.assignee || ticketData.assigned_to) ? {
                    name: (ticketData.assignee || ticketData.assigned_to).name,
                    email: (ticketData.assignee || ticketData.assigned_to).email
                  } : undefined
                },
                chatAccess: {
                  canAccess: false,
                  canSend: false,
                  reason: 'Nenhuma mensagem encontrada',
                  ticketStatus: ticketData.status
                }
              })
              return
            } else {
              console.log('‚úÖ Modo hist√≥rico: mensagens encontradas, permitindo acesso')
            }
          }
        } catch (error) {
          console.log('‚ùå Erro ao verificar mensagens:', error)
          // Em caso de erro, n√£o permitir acesso
          setChatAvailability({
            isAvailable: false,
            isLoading: false,
            error: null,
            canSend: false,
            ticketData: {
              id: ticketData.id.toString(),
              title: ticketData.title,
              ticket_number: ticketData.ticket_number,
              status: ticketData.status,
              priority: ticketData.priority,
              created_by: ticketData.creator ? {
                name: ticketData.creator.name,
                email: ticketData.creator.email
              } : undefined,
              assigned_to: (ticketData.assignee || ticketData.assigned_to) ? {
                name: (ticketData.assignee || ticketData.assigned_to).name,
                email: (ticketData.assignee || ticketData.assigned_to).email
              } : undefined
            },
            chatAccess: {
              canAccess: false,
              canSend: false,
              reason: 'Erro ao verificar mensagens',
              ticketStatus: ticketData.status
            }
          })
          return
        }
      }

      // Se h√° t√©cnico atribu√≠do, verificar acesso via API de mensagens
      console.log(`üîç Verificando acesso ao chat via API de mensagens`)
      
      const response = await fetch(`/api/messages/list?ticket_id=${ticketId}&is_history_mode=${isHistoryMode}`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      })

      console.log(`üìä Status da resposta: ${response.status}`)

      if (!response.ok) {
        const errorText = await response.text()
        console.log(`‚ùå Erro na API de mensagens: ${response.status} - ${errorText}`)
        throw new Error(`Status ${response.status}: ${errorText}`)
      }

      const data = await response.json()
      const { messages, chatAccess } = data
      
      console.log(`‚úÖ Acesso verificado via API de mensagens`)
      console.log(`üìã Chat access:`, chatAccess)
      console.log(`üìã Mensagens encontradas:`, messages?.length || 0)

      // Usar as informa√ß√µes de acesso retornadas pela API
      let isAvailable = chatAccess.canAccess
      let canSend = chatAccess.canSend

      // No modo hist√≥rico, permitir acesso mesmo se a API retornar canAccess: false
      if (isHistoryMode && !isAvailable) {
        console.log('üìö Modo hist√≥rico: for√ßando acesso ao chat para leitura')
        isAvailable = true
        canSend = false // No modo hist√≥rico, sempre apenas leitura
      }

      console.log('‚úÖ Chat dispon√≠vel?', isAvailable)
      console.log('‚úÖ Pode enviar mensagens?', canSend)
      console.log('üìã Motivo:', chatAccess.reason)
      console.log('üìä Status do ticket:', chatAccess.ticketStatus)

      setChatAvailability({
        isAvailable,
        isLoading: false,
        error: null,
        canSend,
        ticketData: {
          id: ticketData.id.toString(),
          title: ticketData.title,
          ticket_number: ticketData.ticket_number,
          status: ticketData.status,
          priority: ticketData.priority,
          created_by: ticketData.creator ? {
            name: ticketData.creator.name,
            email: ticketData.creator.email
          } : undefined,
          assigned_to: (ticketData.assignee || ticketData.assigned_to) ? {
            name: (ticketData.assignee || ticketData.assigned_to).name,
            email: (ticketData.assignee || ticketData.assigned_to).email
          } : undefined
        },
        chatAccess
      })
      
      // Marcar como inicializado ap√≥s primeira verifica√ß√£o bem-sucedida
      if (!hasInitialized) {
        setHasInitialized(true)
      }

      // Se o chat est√° dispon√≠vel e n√£o √© modo hist√≥rico, parar o polling
      if (isAvailable && !isHistoryMode) {
        console.log('‚úÖ Chat dispon√≠vel - parando polling para economizar recursos')
        setShouldPoll(false)
        setIsWaitingForTechnician(false)
      }

    } catch (error) {
      // Se for erro de "no messages", n√£o mostrar como erro
      if (error.message && error.message.includes('chat.noMessages')) {
        console.log('üìö Modo hist√≥rico: sem mensagens existentes - ocultando erro')
        setChatAvailability({
          isAvailable: false,
          isLoading: false,
          error: null,
          canSend: false,
          ticketData: null,
          chatAccess: null
        })
        return
      }
      
      console.error('Erro ao verificar disponibilidade do chat:', error)
      setChatAvailability({
        isAvailable: false,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Erro desconhecido'
      })
    }
  }, [ticketId, hasInitialized])

  // Usar ref para evitar loop infinito
  const checkChatAvailabilityRef = useRef(checkChatAvailability)
  checkChatAvailabilityRef.current = checkChatAvailability

  useEffect(() => {
    if (!ticketId) {
      setChatAvailability({
        isAvailable: false,
        isLoading: false,
        error: null
      })
      return
    }

    // Verifica√ß√£o inicial
    checkChatAvailabilityRef.current()

    // Listener para eventos de mudan√ßa de ticket
    const handleTicketUpdate = (event: CustomEvent) => {
      if (event.detail?.ticketId === ticketId) {
        console.log('üîÑ Evento de atualiza√ß√£o de ticket detectado - verificando chat imediatamente')
        checkChatAvailabilityRef.current()
      }
    }

    // Escutar eventos de atualiza√ß√£o de ticket
    window.addEventListener('ticketUpdated', handleTicketUpdate as EventListener)
    window.addEventListener('ticketAssigned', handleTicketUpdate as EventListener)
    window.addEventListener('ticketAccepted', handleTicketUpdate as EventListener)

    // Se o polling estiver pausado ou n√£o deve mais fazer polling, n√£o criar o interval
    if (pausePolling || !shouldPoll) {
      return () => {
        window.removeEventListener('ticketUpdated', handleTicketUpdate as EventListener)
        window.removeEventListener('ticketAssigned', handleTicketUpdate as EventListener)
        window.removeEventListener('ticketAccepted', handleTicketUpdate as EventListener)
      }
    }

    // Polling autom√°tico para verificar mudan√ßas no ticket (ex: t√©cnico aceitar)
    // Se est√° esperando t√©cnico, verificar mais frequentemente
    const pollingInterval = isWaitingForTechnician ? 500 : 1000 // 500ms se esperando t√©cnico, 1s caso contr√°rio
    const interval = setInterval(() => {
      checkChatAvailabilityRef.current()
    }, pollingInterval)

    return () => {
      clearInterval(interval)
      window.removeEventListener('ticketUpdated', handleTicketUpdate as EventListener)
      window.removeEventListener('ticketAssigned', handleTicketUpdate as EventListener)
      window.removeEventListener('ticketAccepted', handleTicketUpdate as EventListener)
    }
  }, [ticketId, pausePolling, shouldPoll, isWaitingForTechnician]) // Adicionar todas as depend√™ncias

  const refreshAvailability = () => {
    checkChatAvailability()
  }

  const restartPolling = () => {
    setShouldPoll(true)
    setIsWaitingForTechnician(true)
    checkChatAvailability()
  }

  const forceCheck = () => {
    console.log('üîÑ For√ßando verifica√ß√£o imediata do chat')
    checkChatAvailability()
  }

  return {
    ...chatAvailability,
    refreshAvailability,
    restartPolling,
    forceCheck
  }
}
