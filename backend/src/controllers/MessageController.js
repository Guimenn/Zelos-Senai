/**
 * Controller para gerenciamento de mensagens do chat
 * Sistema de chat em tempo real entre criador e t√©cnico do chamado
 */
import prisma from '../../prisma/client.js';
import { createClient } from '@supabase/supabase-js';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { v4 as uuidv4 } from 'uuid';

// Configura√ß√£o do Supabase
const supabaseUrl = process.env.SUPABASE_URL || 'https://pyrxlymsoidmjxjenesb.supabase.co';
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

console.log('üîç Configura√ß√£o do Supabase:');
console.log('üîç URL:', supabaseUrl);
console.log('üîç Key configurada:', supabaseKey ? 'Sim' : 'N√£o');

if (!supabaseKey) {
    console.error('‚ùå SUPABASE_SERVICE_ROLE_KEY n√£o configurada!');
    console.error('‚ùå Usando Prisma apenas');
} else {
    console.log('‚ö†Ô∏è SUPABASE_SERVICE_ROLE_KEY configurada, mas pode n√£o ter permiss√µes adequadas');
    console.log('‚ö†Ô∏è Usando Prisma como fallback principal');
}

// Inicializar Supabase se as chaves estiverem configuradas
const supabase = supabaseKey ? createClient(supabaseUrl, supabaseKey) : null;

// Configura√ß√£o do multer para upload de arquivos
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadDir = 'uploads/chat';
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        const uniqueName = `${uuidv4()}-${file.originalname}`;
        cb(null, uniqueName);
    }
});

const upload = multer({
    storage: storage,
    limits: {
        fileSize: 10 * 1024 * 1024, // 10MB
    },
    fileFilter: (req, file, cb) => {
        // Permitir apenas tipos de arquivo seguros
        const allowedTypes = [
            'image/jpeg', 'image/png', 'image/gif', 'image/webp',
            'application/pdf', 'text/plain', 'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/vnd.ms-excel',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        ];
        
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error('Tipo de arquivo n√£o permitido'), false);
        }
    }
});

/**
 * Fun√ß√£o para verificar se o usu√°rio tem acesso ao chat do ticket
 * Regras:
 * - Criador do chamado pode acessar
 * - T√©cnico atribu√≠do pode acessar
 * - Admin pode acessar todos (exceto os seus pr√≥prios)
 */
async function checkChatAccess(user, ticket) {
    console.log('üîç Verificando acesso ao chat:', {
        userId: user.id,
        userRole: user.role,
        ticketId: ticket.id,
        ticketCreator: ticket.created_by,
        ticketAssignedTo: ticket.assigned_to
    });

    // Converter IDs para n√∫meros para compara√ß√£o mais robusta
    const userId = parseInt(user.id);
    const ticketCreatorId = parseInt(ticket.created_by);
    const ticketAssignedToId = ticket.assigned_to ? parseInt(ticket.assigned_to) : null;

    console.log('üîç IDs convertidos:', {
        userId,
        ticketCreatorId,
        ticketAssignedToId
    });

    // Verificar se h√° t√©cnico atribu√≠do (regra geral)
    const hasAssignee = !!(ticket.assigned_to);
    if (!hasAssignee) {
        console.log('‚ùå Sem t√©cnico atribu√≠do');
        return { canAccess: false, canSend: false, reason: 'chat.waitingTechnician' };
    }

    // Admin pode acessar todos os chats (ap√≥s t√©cnico aceitar)
    if (user.role === 'Admin') {
        // Se o admin criou o ticket, ele pode enviar mensagens
        if (ticketCreatorId === userId) {
            console.log('‚úÖ Admin - criador do ticket');
            return { canAccess: true, canSend: true, reason: 'chat.adminCreator' };
        }
        // Se n√£o criou, s√≥ pode visualizar
        console.log('‚úÖ Admin - apenas visualiza√ß√£o');
        return { canAccess: true, canSend: false, reason: 'chat.adminViewOnly' };
    }

    // Criador do chamado pode acessar e enviar mensagens
    if (ticketCreatorId === userId) {
        console.log('‚úÖ Criador do ticket');
        return { canAccess: true, canSend: true, reason: 'chat.ticketCreator' };
    }

    // T√©cnico atribu√≠do pode acessar e enviar mensagens
    if (ticketAssignedToId === userId) {
        console.log('‚úÖ T√©cnico atribu√≠do');
        return { canAccess: true, canSend: true, reason: 'chat.assignedTechnician' };
    }

    // Outros usu√°rios n√£o t√™m acesso
    console.log('‚ùå Sem permiss√£o para acessar este chat');
    return { canAccess: false, canSend: false, reason: 'chat.noPermission' };
}

/**
 * Controller para enviar uma mensagem
 * POST /api/messages/send
 */
async function sendMessageController(req, res) {
    console.log('üîç sendMessageController iniciado');
    console.log('üîç Dados recebidos:', req.body);
    console.log('üîç Usu√°rio autenticado:', req.user);
    console.log('üîç Headers:', req.headers);
    
    try {
        const { ticket_id, content, attachment_url, reply_to_id } = req.body;

        console.log('üîç Dados extra√≠dos:', {
            ticket_id,
            content,
            attachment_url,
            reply_to_id
        });

        // Valida√ß√µes b√°sicas
        if (!ticket_id) {
            console.error('‚ùå ID do ticket n√£o fornecido');
            return res.status(400).json({ message: 'ID do ticket √© obrigat√≥rio' });
        }

        if ((!content || (typeof content === 'string' && content.trim() === '')) && !attachment_url) {
            console.error('‚ùå Nem conte√∫do nem anexo fornecidos');
            return res.status(400).json({ message: 'Conte√∫do ou anexo √© obrigat√≥rio' });
        }

        // Verificar se o ticket existe
        const ticket = await prisma.ticket.findUnique({
            where: { id: parseInt(ticket_id) }
        });

        if (!ticket) {
            return res.status(404).json({ message: 'Ticket n√£o encontrado' });
        }

        // Verificar se o usu√°rio tem acesso ao chat
        const chatAccess = await checkChatAccess(req.user, ticket);
        if (!chatAccess.canAccess) {
            return res.status(403).json({ message: chatAccess.reason });
        }

        // Verificar se o ticket est√° fechado (n√£o permite envio de mensagens)
        const isClosed = ['Closed', 'Cancelled', 'Resolved'].includes(ticket.status);
        if (isClosed) {
            return res.status(403).json({ message: 'N√£o √© poss√≠vel enviar mensagens em tickets fechados' });
        }

        // Verificar se o usu√°rio pode enviar mensagens
        if (!chatAccess.canSend) {
            return res.status(403).json({ message: chatAccess.reason });
        }

        // Criar mensagem usando Supabase (para Realtime funcionar) ou Prisma (fallback)
        let message;
        
        if (supabase) {
            console.log('üîç Tentando criar mensagem no Supabase para ticket:', parseInt(ticket_id));
            
            try {
                const { data: supabaseMessage, error } = await supabase
                    .from('messages')
                    .insert({
                        ticket_id: parseInt(ticket_id),
                        sender_id: req.user.id,
                        content: (content && content.trim() !== '') ? content.trim() : null,
                        attachment_url: attachment_url || null,
                        reply_to_id: reply_to_id || null
                    })
                    .select()
                    .single();

                if (error) {
                    console.error('‚ùå Erro ao criar mensagem no Supabase:', error);
                    console.error('‚ùå Detalhes do erro:', JSON.stringify(error, null, 2));
                    console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                    message = null; // For√ßar fallback
                } else {
                    message = supabaseMessage;
                    console.log('‚úÖ Mensagem criada no Supabase:', message.id);
                }
            } catch (supabaseError) {
                console.error('‚ùå Erro geral no Supabase:', supabaseError);
                console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                message = null; // For√ßar fallback
            }
        } else {
            console.log('üîç Supabase n√£o dispon√≠vel, usando Prisma diretamente');
        }
        
        // Fallback para Prisma se Supabase n√£o estiver dispon√≠vel ou falhar
        if (!message) {
            console.log('üîÑ Criando mensagem no Prisma...');
            try {
                message = await prisma.messages.create({
                    data: {
                        ticket_id: parseInt(ticket_id),
                        sender_id: req.user.id,
                        content: (content && content.trim() !== '') ? content.trim() : null,
                        attachment_url: attachment_url || null,
                        reply_to_id: reply_to_id || null
                    }
                });
                
                console.log('‚úÖ Mensagem criada no Prisma:', message.id);
            } catch (prismaError) {
                console.error('‚ùå Erro ao criar mensagem no Prisma:', prismaError);
                throw prismaError;
            }
        }

        // Buscar dados do remetente
        const sender = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: {
                id: true,
                name: true,
                email: true,
                avatar: true
            }
        });

        // Retornar mensagem com dados do remetente e campo FROM_Me
        const response = {
            ...message,
            id: message.id.toString(), // Garantir que o ID seja string
            sender: sender,
            FROM_Me: true // Sempre true para mensagens enviadas pelo usu√°rio atual
        };

        console.log('üì§ Retornando mensagem criada:', response.id, 'Tipo:', typeof response.id);
        return res.status(201).json(response);

    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        console.error('Stack trace:', error.stack);
        return res.status(500).json({ 
            message: 'Erro interno do servidor',
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
}

/**
 * Controller para listar mensagens de um ticket
 * GET /api/messages/list?ticket_id=xxx
 */
async function getMessagesController(req, res) {
    try {
        const { ticket_id, page = 1, limit = 200 } = req.query;

        if (!ticket_id) {
            return res.status(400).json({ message: 'ID do ticket √© obrigat√≥rio' });
        }

        // Verificar se o ticket existe
        const ticket = await prisma.ticket.findUnique({
            where: { id: parseInt(ticket_id) }
        });

        if (!ticket) {
            return res.status(404).json({ message: 'Ticket n√£o encontrado' });
        }

        // Verificar se o usu√°rio tem acesso ao chat
        const chatAccess = await checkChatAccess(req.user, ticket);
        if (!chatAccess.canAccess) {
            return res.status(403).json({ message: chatAccess.reason });
        }

        // Buscar mensagens usando Supabase ou Prisma (fallback)
        let messages;
        
        if (supabase) {
            console.log('üîç Tentando buscar mensagens no Supabase para ticket:', parseInt(ticket_id));
            
            try {
                const { data: supabaseMessages, error } = await supabase
                    .from('messages')
                    .select('*')
                    .eq('ticket_id', parseInt(ticket_id))
                    .order('created_at', { ascending: true })
                    .range((page - 1) * limit, page * limit - 1);

                if (error) {
                    console.error('‚ùå Erro ao buscar mensagens no Supabase:', error);
                    console.error('‚ùå Detalhes do erro:', JSON.stringify(error, null, 2));
                    console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                    messages = null; // For√ßar fallback
                } else {
                    messages = supabaseMessages;
                    console.log('‚úÖ Mensagens encontradas no Supabase:', messages?.length || 0);
                }
            } catch (supabaseError) {
                console.error('‚ùå Erro geral no Supabase:', supabaseError);
                console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                messages = null; // For√ßar fallback
            }
        } else {
            console.log('üîç Supabase n√£o dispon√≠vel, usando Prisma diretamente');
        }
        
        // Fallback para Prisma se Supabase n√£o estiver dispon√≠vel ou falhar
        if (!messages) {
            console.log('üîÑ Buscando mensagens no Prisma...');
            
            // Buscar mensagens exclu√≠das "s√≥ para mim" por este usu√°rio
            const deletedMessageIds = await prisma.deleted_messages.findMany({
                where: {
                    user_id: req.user.id
                },
                select: {
                    message_id: true
                }
            });

            const deletedIds = deletedMessageIds.map(d => d.message_id);
            console.log('üîç Mensagens exclu√≠das s√≥ para mim:', deletedIds);

            messages = await prisma.messages.findMany({
                where: {
                    ticket_id: parseInt(ticket_id),
                    // Excluir mensagens que foram deletadas "s√≥ para mim" por este usu√°rio
                    id: {
                        notIn: deletedIds
                    }
                },
                orderBy: {
                    created_at: 'asc'
                },
                skip: (page - 1) * limit,
                take: limit,
                select: {
                    id: true,
                    ticket_id: true,
                    sender_id: true,
                    content: true,
                    attachment_url: true,
                    created_at: true,
                    edited_at: true,
                    is_deleted: true,
                    deleted_at: true,
                    deleted_by: true,
                    reply_to_id: true
                }
            });
            
            console.log('‚úÖ Mensagens encontradas no Prisma:', messages?.length || 0);
            if (messages.length > 0) {
                console.log('üìã Primeira mensagem:', JSON.stringify(messages[0], null, 2));
            }
        }

        // Buscar dados dos remetentes (otimizado)
        const senderIds = [...new Set(messages.map(msg => msg.sender_id))];
        const senders = senderIds.length > 0 ? await prisma.user.findMany({
            where: { id: { in: senderIds } },
            select: {
                id: true,
                name: true,
                email: true,
                avatar: true
            }
        }) : [];

        // Mapear mensagens com dados dos remetentes e campo FROM_Me
        const messagesWithSenders = messages.map(message => {
            const sender = senders.find(sender => sender.id === message.sender_id);
            const isFromCurrentUser = message.sender_id === req.user.id;
            
            return {
                ...message,
                id: message.id.toString(), // Garantir que o ID seja string
                sender: sender,
                FROM_Me: isFromCurrentUser
            };
        });

        return res.status(200).json({
            messages: messagesWithSenders,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: messages.length
            },
            chatAccess: {
                canAccess: chatAccess.canAccess,
                canSend: chatAccess.canSend,
                reason: chatAccess.reason,
                ticketStatus: ticket.status
            }
        });

    } catch (error) {
        console.error('Erro ao buscar mensagens:', error);
        return res.status(500).json({ message: 'Erro interno do servidor' });
    }
}

/**
 * Controller para upload de anexos
 * POST /api/messages/upload
 */
async function uploadAttachmentController(req, res) {
    console.log('üîç Upload iniciado - Supabase configurado:', !!supabase);
    console.log('üîç Supabase URL:', supabaseUrl);
    console.log('üîç Supabase Key configurada:', !!supabaseKey);
    
    try {
        upload.single('file')(req, res, async (err) => {
            console.log('üîç Multer callback executado');
            
            if (err) {
                console.error('‚ùå Erro do Multer:', err);
                if (err instanceof multer.MulterError) {
                    if (err.code === 'LIMIT_FILE_SIZE') {
                        return res.status(400).json({ message: 'Arquivo muito grande. M√°ximo 10MB.' });
                    }
                }
                return res.status(400).json({ message: err.message });
            }

            if (!req.file) {
                console.error('‚ùå Nenhum arquivo enviado');
                return res.status(400).json({ message: 'Nenhum arquivo enviado' });
            }

            console.log('üìé Arquivo recebido:', {
                originalname: req.file.originalname,
                filename: req.file.filename,
                mimetype: req.file.mimetype,
                size: req.file.size,
                path: req.file.path
            });

            try {
                // Verificar se Supabase est√° configurado
                if (!supabase) {
                    console.error('‚ùå Supabase n√£o configurado - usando fallback local');
                    // Fallback: retornar URL local tempor√°ria
                    const localUrl = `http://localhost:3001/uploads/chat/${req.file.filename}`;
                    return res.status(200).json({
                        success: true,
                        data: {
                            filename: req.file.originalname,
                            url: localUrl,
                            size: req.file.size,
                            type: req.file.mimetype
                        }
                    });
                }

                // Upload para Supabase Storage
                console.log('üìé Iniciando upload para Supabase...');
                const fileBuffer = fs.readFileSync(req.file.path);
                const fileName = `chat/${req.file.filename}`;
                const bucketName = 'Anexo-chamado'; // Usar o mesmo bucket do AttachmentController

                // Garantir que o bucket existe
                try {
                    await supabase.storage.createBucket(bucketName, { public: true });
                } catch (e) {
                    // Ignorar erro se bucket j√° existe
                }

                const { data, error } = await supabase.storage
                    .from(bucketName)
                    .upload(fileName, fileBuffer, {
                        contentType: req.file.mimetype,
                        upsert: false
                    });

                if (error) {
                    console.error('‚ùå Erro no upload para Supabase:', error);
                    console.error('‚ùå Detalhes do erro:', JSON.stringify(error, null, 2));
                    return res.status(500).json({ message: 'Erro no upload do arquivo' });
                }

                console.log('‚úÖ Upload para Supabase conclu√≠do:', data);

                // Obter URL p√∫blica
                const { data: publicUrl } = supabase.storage
                    .from(bucketName)
                    .getPublicUrl(fileName);

                console.log('üîó URL p√∫blica gerada:', publicUrl.publicUrl);

                // Remover arquivo tempor√°rio
                fs.unlinkSync(req.file.path);

                return res.status(200).json({
                    success: true,
                    data: {
                        filename: req.file.originalname,
                        url: publicUrl.publicUrl,
                        size: req.file.size,
                        type: req.file.mimetype
                    }
                });

            } catch (uploadError) {
                console.error('‚ùå Erro no upload:', uploadError);
                console.error('‚ùå Stack trace:', uploadError.stack);
                // Remover arquivo tempor√°rio em caso de erro
                if (fs.existsSync(req.file.path)) {
                    fs.unlinkSync(req.file.path);
                }
                return res.status(500).json({ message: 'Erro no upload do arquivo' });
            }
        });

    } catch (error) {
        console.error('‚ùå Erro no upload de anexo:', error);
        console.error('‚ùå Stack trace:', error.stack);
        return res.status(500).json({ message: 'Erro interno do servidor' });
    }
}

/**
 * Controller para editar uma mensagem
 * PUT /api/messages/:id
 */
async function editMessageController(req, res) {
    try {
        const { id } = req.params;
        const { content } = req.body;

        console.log('üîç Editando mensagem - ID recebido:', id, 'Tipo:', typeof id);
        console.log('üîç Editando mensagem - ID convertido:', parseInt(id));

        if (!content || !content.trim()) {
            return res.status(400).json({ message: 'Conte√∫do da mensagem √© obrigat√≥rio' });
        }

        // Verificar se a mensagem existe
        const existingMessage = await prisma.messages.findUnique({
            where: { id: parseInt(id) }
        });

        console.log('üîç Mensagem encontrada:', existingMessage ? 'Sim' : 'N√£o');

        if (!existingMessage) {
            return res.status(404).json({ message: 'Mensagem n√£o encontrada' });
        }

        // Verificar se a mensagem foi deletada
        if (existingMessage.is_deleted) {
            return res.status(400).json({ message: 'N√£o √© poss√≠vel editar uma mensagem deletada' });
        }

        // Verificar se o usu√°rio √© o remetente da mensagem
        if (existingMessage.sender_id !== req.user.id) {
            return res.status(403).json({ message: 'Voc√™ s√≥ pode editar suas pr√≥prias mensagens' });
        }

        // Verificar se o ticket ainda est√° aberto
        const ticket = await prisma.ticket.findUnique({
            where: { id: existingMessage.ticket_id }
        });

        if (!ticket) {
            return res.status(404).json({ message: 'Ticket n√£o encontrado' });
        }

        const isClosed = ['Closed', 'Cancelled', 'Resolved'].includes(ticket.status);
        if (isClosed) {
            return res.status(403).json({ message: 'N√£o √© poss√≠vel editar mensagens em tickets fechados' });
        }

        // Atualizar mensagem usando Supabase ou Prisma
        let updatedMessage;
        
        if (supabase) {
            console.log('üîç Tentando editar mensagem no Supabase:', id);
            
            try {
                const { data: supabaseMessage, error } = await supabase
                    .from('messages')
                    .update({
                        content: content.trim(),
                        edited_at: new Date().toISOString()
                    })
                    .eq('id', parseInt(id))
                    .eq('sender_id', req.user.id)
                    .eq('is_deleted', false)
                    .select()
                    .single();

                if (error) {
                    console.error('‚ùå Erro ao editar mensagem no Supabase:', error);
                    console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                    updatedMessage = null; // For√ßar fallback
                } else {
                    updatedMessage = supabaseMessage;
                    console.log('‚úÖ Mensagem editada no Supabase:', updatedMessage.id);
                }
            } catch (supabaseError) {
                console.error('‚ùå Erro geral no Supabase:', supabaseError);
                console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                updatedMessage = null; // For√ßar fallback
            }
        } else {
            console.log('üîç Supabase n√£o dispon√≠vel, usando Prisma diretamente');
        }
        
        // Fallback para Prisma se Supabase n√£o estiver dispon√≠vel ou falhar
        if (!updatedMessage) {
            console.log('üîÑ Editando mensagem no Prisma...');
            updatedMessage = await prisma.messages.update({
                where: { 
                    id: parseInt(id)
                },
                data: {
                    content: content.trim(),
                    edited_at: new Date()
                }
            });
            
            console.log('‚úÖ Mensagem editada no Prisma:', updatedMessage.id);
            console.log('üìã Conte√∫do editado:', updatedMessage.content);
            console.log('üìã Data de edi√ß√£o:', updatedMessage.edited_at);
        }

        // Buscar dados do remetente
        const sender = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: {
                id: true,
                name: true,
                email: true,
                avatar: true
            }
        });

        // Retornar mensagem editada com dados do remetente
        const response = {
            ...updatedMessage,
            id: updatedMessage.id.toString(), // Garantir que o ID seja string
            sender: sender,
            FROM_Me: true
        };

        console.log('üì§ Retornando mensagem editada:', response.id, 'Tipo:', typeof response.id);
        return res.status(200).json(response);

    } catch (error) {
        console.error('Erro ao editar mensagem:', error);
        return res.status(500).json({ message: 'Erro interno do servidor' });
    }
}

/**
 * Controller para excluir uma mensagem
 * DELETE /api/messages/:id
 */
async function deleteMessageController(req, res) {
    try {
        const { id } = req.params;
        const { deleteForAll = false } = req.body;

        // Verificar se a mensagem existe
        const existingMessage = await prisma.messages.findUnique({
            where: { id: parseInt(id) }
        });

        if (!existingMessage) {
            return res.status(404).json({ message: 'Mensagem n√£o encontrada' });
        }

        // Verificar se a mensagem j√° foi deletada
        if (existingMessage.is_deleted) {
            return res.status(400).json({ message: 'Mensagem j√° foi deletada' });
        }

        // Verificar se o usu√°rio √© o remetente da mensagem
        if (existingMessage.sender_id !== req.user.id) {
            return res.status(403).json({ message: 'Voc√™ s√≥ pode excluir suas pr√≥prias mensagens' });
        }

        // Verificar se o ticket ainda est√° aberto (apenas para exclus√£o para todos)
        if (deleteForAll) {
            const ticket = await prisma.ticket.findUnique({
                where: { id: existingMessage.ticket_id }
            });

            if (!ticket) {
                return res.status(404).json({ message: 'Ticket n√£o encontrado' });
            }

            const isClosed = ['Closed', 'Cancelled', 'Resolved'].includes(ticket.status);
            if (isClosed) {
                return res.status(403).json({ message: 'N√£o √© poss√≠vel excluir mensagens em tickets fechados' });
            }
        }

        let updatedMessage;
        
        if (deleteForAll) {
            // Exclus√£o para todos - marcar como deletada no banco
            if (supabase) {
                console.log('üîç Tentando excluir mensagem para todos no Supabase:', id);
                
                try {
                    const { data: supabaseMessage, error } = await supabase
                        .from('messages')
                        .update({
                            is_deleted: true,
                            deleted_at: new Date().toISOString(),
                            deleted_by: req.user.id,
                            content: 'Mensagem apagada',
                            attachment_url: null
                        })
                        .eq('id', parseInt(id))
                        .eq('sender_id', req.user.id)
                        .eq('is_deleted', false)
                        .select()
                        .single();

                    if (error) {
                        console.error('‚ùå Erro ao excluir mensagem no Supabase:', error);
                        console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                        updatedMessage = null; // For√ßar fallback
                    } else {
                        updatedMessage = supabaseMessage;
                        console.log('‚úÖ Mensagem exclu√≠da para todos no Supabase:', updatedMessage.id);
                    }
                } catch (supabaseError) {
                    console.error('‚ùå Erro geral no Supabase:', supabaseError);
                    console.log('üîÑ Fallback para Prisma devido ao erro do Supabase');
                    updatedMessage = null; // For√ßar fallback
                }
            } else {
                console.log('üîç Supabase n√£o dispon√≠vel, usando Prisma diretamente');
            }
            
            // Fallback para Prisma se Supabase n√£o estiver dispon√≠vel ou falhar
            if (!updatedMessage) {
                console.log('üîÑ Excluindo mensagem para todos no Prisma...');
                updatedMessage = await prisma.messages.update({
                    where: { 
                        id: parseInt(id)
                    },
                    data: {
                        is_deleted: true,
                        deleted_at: new Date(),
                        deleted_by: req.user.id,
                        content: 'Mensagem apagada',
                        attachment_url: null
                    }
                });
                
                console.log('‚úÖ Mensagem exclu√≠da para todos no Prisma:', updatedMessage.id);
            }
        } else {
            // Exclus√£o s√≥ para mim - salvar no banco de dados
            console.log('üîÑ Excluindo mensagem s√≥ para mim no banco...');
            console.log('üîç Dados da exclus√£o:', { messageId: parseInt(id), userId: req.user.id });
            
            try {
                // Verificar se j√° n√£o foi exclu√≠da por este usu√°rio
                const existingDeletion = await prisma.deleted_messages.findFirst({
                    where: {
                        message_id: parseInt(id),
                        user_id: req.user.id
                    }
                });

                console.log('üîç Exclus√£o existente encontrada:', existingDeletion ? 'Sim' : 'N√£o');

                if (!existingDeletion) {
                    // Criar registro de exclus√£o
                    const deletion = await prisma.deleted_messages.create({
                        data: {
                            message_id: parseInt(id),
                            user_id: req.user.id
                        }
                    });
                    console.log('‚úÖ Mensagem exclu√≠da s√≥ para mim no banco:', id);
                    console.log('üìã Registro de exclus√£o criado:', deletion.id);
                } else {
                    console.log('‚ÑπÔ∏è Mensagem j√° estava exclu√≠da s√≥ para mim:', id);
                }
                
                updatedMessage = existingMessage;
            } catch (deletionError) {
                console.error('‚ùå Erro ao excluir mensagem s√≥ para mim:', deletionError);
                throw deletionError;
            }
        }

        // Buscar dados do remetente
        const sender = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: {
                id: true,
                name: true,
                email: true,
                avatar: true
            }
        });

        // Retornar resposta
        const response = {
            ...updatedMessage,
            id: updatedMessage.id.toString(), // Garantir que o ID seja string
            sender: sender,
            FROM_Me: true,
            deletedForAll: deleteForAll
        };

        console.log('üì§ Retornando mensagem exclu√≠da:', response.id, 'Tipo:', typeof response.id);
        return res.status(200).json(response);

    } catch (error) {
        console.error('Erro ao excluir mensagem:', error);
        return res.status(500).json({ message: 'Erro interno do servidor' });
    }
}

/**
 * Controller para obter contagem de mensagens n√£o lidas
 * GET /api/messages/unread-count?ticket_id=xxx
 */
async function getUnreadCountController(req, res) {
    try {
        const { ticket_id, since } = req.query;

        if (!ticket_id) {
            return res.status(400).json({ message: 'ID do ticket √© obrigat√≥rio' });
        }

        // Verificar se o ticket existe
        const ticket = await prisma.ticket.findUnique({
            where: { id: parseInt(ticket_id) }
        });

        if (!ticket) {
            return res.status(404).json({ message: 'Ticket n√£o encontrado' });
        }

        // Verificar se o usu√°rio tem acesso ao chat
        const chatAccess = await checkChatAccess(req.user, ticket);
        
        if (!chatAccess.canAccess) {
            return res.status(403).json({ message: chatAccess.reason });
        }

        // Construir filtros para mensagens n√£o lidas
        const whereClause = {
            ticket_id: parseInt(ticket_id),
            sender_id: {
                not: req.user.id // N√£o contar mensagens pr√≥prias
            },
            is_deleted: false
        };

        // Se foi fornecido um timestamp "since", filtrar mensagens criadas ap√≥s essa data
        if (since) {
            try {
                const sinceDate = new Date(since);
                if (!isNaN(sinceDate.getTime())) {
                    whereClause.created_at = {
                        gt: sinceDate
                    };
                }
            } catch (error) {
                console.error('Erro ao processar par√¢metro since:', error);
                // Continuar sem o filtro de data se houver erro
            }
        }

        const unreadCount = await prisma.messages.count({
            where: whereClause
        });

        return res.status(200).json({
            unread_count: unreadCount,
            ticket_id: parseInt(ticket_id),
            since: since || null
        });

    } catch (error) {
        console.error('Erro ao buscar contagem de mensagens n√£o lidas:', error);
        return res.status(500).json({ message: 'Erro interno do servidor' });
    }
}

export {
    sendMessageController,
    getMessagesController,
    uploadAttachmentController,
    editMessageController,
    deleteMessageController,
    getUnreadCountController,
    checkChatAccess
};
