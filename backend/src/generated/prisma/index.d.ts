
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Subcategory
 * 
 */
export type Subcategory = $Result.DefaultSelection<Prisma.$SubcategoryPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model TicketHistory
 * 
 */
export type TicketHistory = $Result.DefaultSelection<Prisma.$TicketHistoryPayload>
/**
 * Model TicketAssignment
 * 
 */
export type TicketAssignment = $Result.DefaultSelection<Prisma.$TicketAssignmentPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model ResponseTemplate
 * 
 */
export type ResponseTemplate = $Result.DefaultSelection<Prisma.$ResponseTemplatePayload>
/**
 * Model SLA
 * 
 */
export type SLA = $Result.DefaultSelection<Prisma.$SLAPayload>
/**
 * Model TicketStatistics
 * 
 */
export type TicketStatistics = $Result.DefaultSelection<Prisma.$TicketStatisticsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  Admin: 'Admin',
  Agent: 'Agent',
  Client: 'Client'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ClientType: {
  Individual: 'Individual',
  Business: 'Business',
  Enterprise: 'Enterprise'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const Priority: {
  Low: 'Low',
  Medium: 'Medium',
  High: 'High',
  Critical: 'Critical'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const TicketStatus: {
  Open: 'Open',
  InProgress: 'InProgress',
  WaitingForClient: 'WaitingForClient',
  WaitingForThirdParty: 'WaitingForThirdParty',
  Resolved: 'Resolved',
  Closed: 'Closed',
  Cancelled: 'Cancelled'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subcategory`: Exposes CRUD operations for the **Subcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subcategories
    * const subcategories = await prisma.subcategory.findMany()
    * ```
    */
  get subcategory(): Prisma.SubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketHistory`: Exposes CRUD operations for the **TicketHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketHistories
    * const ticketHistories = await prisma.ticketHistory.findMany()
    * ```
    */
  get ticketHistory(): Prisma.TicketHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketAssignment`: Exposes CRUD operations for the **TicketAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAssignments
    * const ticketAssignments = await prisma.ticketAssignment.findMany()
    * ```
    */
  get ticketAssignment(): Prisma.TicketAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.responseTemplate`: Exposes CRUD operations for the **ResponseTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponseTemplates
    * const responseTemplates = await prisma.responseTemplate.findMany()
    * ```
    */
  get responseTemplate(): Prisma.ResponseTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sLA`: Exposes CRUD operations for the **SLA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SLAS
    * const sLAS = await prisma.sLA.findMany()
    * ```
    */
  get sLA(): Prisma.SLADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketStatistics`: Exposes CRUD operations for the **TicketStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketStatistics
    * const ticketStatistics = await prisma.ticketStatistics.findMany()
    * ```
    */
  get ticketStatistics(): Prisma.TicketStatisticsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Agent: 'Agent',
    Client: 'Client',
    Category: 'Category',
    Subcategory: 'Subcategory',
    Ticket: 'Ticket',
    Comment: 'Comment',
    Attachment: 'Attachment',
    TicketHistory: 'TicketHistory',
    TicketAssignment: 'TicketAssignment',
    SystemSettings: 'SystemSettings',
    ResponseTemplate: 'ResponseTemplate',
    SLA: 'SLA',
    TicketStatistics: 'TicketStatistics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "agent" | "client" | "category" | "subcategory" | "ticket" | "comment" | "attachment" | "ticketHistory" | "ticketAssignment" | "systemSettings" | "responseTemplate" | "sLA" | "ticketStatistics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Subcategory: {
        payload: Prisma.$SubcategoryPayload<ExtArgs>
        fields: Prisma.SubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findFirst: {
            args: Prisma.SubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findMany: {
            args: Prisma.SubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          create: {
            args: Prisma.SubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          createMany: {
            args: Prisma.SubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          delete: {
            args: Prisma.SubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          update: {
            args: Prisma.SubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.SubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          aggregate: {
            args: Prisma.SubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubcategory>
          }
          groupBy: {
            args: Prisma.SubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      TicketHistory: {
        payload: Prisma.$TicketHistoryPayload<ExtArgs>
        fields: Prisma.TicketHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          findFirst: {
            args: Prisma.TicketHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          findMany: {
            args: Prisma.TicketHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>[]
          }
          create: {
            args: Prisma.TicketHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          createMany: {
            args: Prisma.TicketHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>[]
          }
          delete: {
            args: Prisma.TicketHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          update: {
            args: Prisma.TicketHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TicketHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>[]
          }
          upsert: {
            args: Prisma.TicketHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketHistoryPayload>
          }
          aggregate: {
            args: Prisma.TicketHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketHistory>
          }
          groupBy: {
            args: Prisma.TicketHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TicketHistoryCountAggregateOutputType> | number
          }
        }
      }
      TicketAssignment: {
        payload: Prisma.$TicketAssignmentPayload<ExtArgs>
        fields: Prisma.TicketAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>
          }
          findMany: {
            args: Prisma.TicketAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>[]
          }
          create: {
            args: Prisma.TicketAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>
          }
          createMany: {
            args: Prisma.TicketAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TicketAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>
          }
          update: {
            args: Prisma.TicketAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.TicketAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAssignment>
          }
          groupBy: {
            args: Prisma.TicketAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAssignmentCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      ResponseTemplate: {
        payload: Prisma.$ResponseTemplatePayload<ExtArgs>
        fields: Prisma.ResponseTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponseTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponseTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>
          }
          findFirst: {
            args: Prisma.ResponseTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponseTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>
          }
          findMany: {
            args: Prisma.ResponseTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>[]
          }
          create: {
            args: Prisma.ResponseTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>
          }
          createMany: {
            args: Prisma.ResponseTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponseTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>[]
          }
          delete: {
            args: Prisma.ResponseTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>
          }
          update: {
            args: Prisma.ResponseTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ResponseTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponseTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResponseTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ResponseTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseTemplatePayload>
          }
          aggregate: {
            args: Prisma.ResponseTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponseTemplate>
          }
          groupBy: {
            args: Prisma.ResponseTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponseTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponseTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ResponseTemplateCountAggregateOutputType> | number
          }
        }
      }
      SLA: {
        payload: Prisma.$SLAPayload<ExtArgs>
        fields: Prisma.SLAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SLAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SLAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>
          }
          findFirst: {
            args: Prisma.SLAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SLAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>
          }
          findMany: {
            args: Prisma.SLAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>[]
          }
          create: {
            args: Prisma.SLACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>
          }
          createMany: {
            args: Prisma.SLACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SLACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>[]
          }
          delete: {
            args: Prisma.SLADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>
          }
          update: {
            args: Prisma.SLAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>
          }
          deleteMany: {
            args: Prisma.SLADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SLAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SLAUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>[]
          }
          upsert: {
            args: Prisma.SLAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SLAPayload>
          }
          aggregate: {
            args: Prisma.SLAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSLA>
          }
          groupBy: {
            args: Prisma.SLAGroupByArgs<ExtArgs>
            result: $Utils.Optional<SLAGroupByOutputType>[]
          }
          count: {
            args: Prisma.SLACountArgs<ExtArgs>
            result: $Utils.Optional<SLACountAggregateOutputType> | number
          }
        }
      }
      TicketStatistics: {
        payload: Prisma.$TicketStatisticsPayload<ExtArgs>
        fields: Prisma.TicketStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>
          }
          findFirst: {
            args: Prisma.TicketStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>
          }
          findMany: {
            args: Prisma.TicketStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>[]
          }
          create: {
            args: Prisma.TicketStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>
          }
          createMany: {
            args: Prisma.TicketStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>[]
          }
          delete: {
            args: Prisma.TicketStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>
          }
          update: {
            args: Prisma.TicketStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.TicketStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.TicketStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketStatisticsPayload>
          }
          aggregate: {
            args: Prisma.TicketStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketStatistics>
          }
          groupBy: {
            args: Prisma.TicketStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketStatisticsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    agent?: AgentOmit
    client?: ClientOmit
    category?: CategoryOmit
    subcategory?: SubcategoryOmit
    ticket?: TicketOmit
    comment?: CommentOmit
    attachment?: AttachmentOmit
    ticketHistory?: TicketHistoryOmit
    ticketAssignment?: TicketAssignmentOmit
    systemSettings?: SystemSettingsOmit
    responseTemplate?: ResponseTemplateOmit
    sLA?: SLAOmit
    ticketStatistics?: TicketStatisticsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tickets_created: number
    tickets_assigned: number
    ticket_comments: number
    ticket_assignments: number
    ticket_history: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets_created?: boolean | UserCountOutputTypeCountTickets_createdArgs
    tickets_assigned?: boolean | UserCountOutputTypeCountTickets_assignedArgs
    ticket_comments?: boolean | UserCountOutputTypeCountTicket_commentsArgs
    ticket_assignments?: boolean | UserCountOutputTypeCountTicket_assignmentsArgs
    ticket_history?: boolean | UserCountOutputTypeCountTicket_historyArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTickets_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTickets_assignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicket_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicket_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicket_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHistoryWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    ticket_assignments: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket_assignments?: boolean | AgentCountOutputTypeCountTicket_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTicket_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAssignmentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    tickets: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | ClientCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    tickets: number
    subcategories: number
    response_templates: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | CategoryCountOutputTypeCountTicketsArgs
    subcategories?: boolean | CategoryCountOutputTypeCountSubcategoriesArgs
    response_templates?: boolean | CategoryCountOutputTypeCountResponse_templatesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountResponse_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseTemplateWhereInput
  }


  /**
   * Count Type SubcategoryCountOutputType
   */

  export type SubcategoryCountOutputType = {
    tickets: number
  }

  export type SubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | SubcategoryCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcategoryCountOutputType
     */
    select?: SubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    comments: number
    attachments: number
    ticket_history: number
    ticket_assignments: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | TicketCountOutputTypeCountCommentsArgs
    attachments?: boolean | TicketCountOutputTypeCountAttachmentsArgs
    ticket_history?: boolean | TicketCountOutputTypeCountTicket_historyArgs
    ticket_assignments?: boolean | TicketCountOutputTypeCountTicket_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicket_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHistoryWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicket_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAssignmentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    attachments: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | CommentCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    created_at: Date | null
    modified_at: Date | null
    role: $Enums.Role | null
    hashed_password: string | null
    is_active: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    created_at: Date | null
    modified_at: Date | null
    role: $Enums.Role | null
    hashed_password: string | null
    is_active: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    avatar: number
    created_at: number
    modified_at: number
    role: number
    hashed_password: number
    is_active: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    avatar?: true
    created_at?: true
    modified_at?: true
    role?: true
    hashed_password?: true
    is_active?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    avatar?: true
    created_at?: true
    modified_at?: true
    role?: true
    hashed_password?: true
    is_active?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    avatar?: true
    created_at?: true
    modified_at?: true
    role?: true
    hashed_password?: true
    is_active?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string | null
    avatar: string | null
    created_at: Date
    modified_at: Date
    role: $Enums.Role
    hashed_password: string
    is_active: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    created_at?: boolean
    modified_at?: boolean
    role?: boolean
    hashed_password?: boolean
    is_active?: boolean
    agent?: boolean | User$agentArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    tickets_created?: boolean | User$tickets_createdArgs<ExtArgs>
    tickets_assigned?: boolean | User$tickets_assignedArgs<ExtArgs>
    ticket_comments?: boolean | User$ticket_commentsArgs<ExtArgs>
    ticket_assignments?: boolean | User$ticket_assignmentsArgs<ExtArgs>
    ticket_history?: boolean | User$ticket_historyArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    created_at?: boolean
    modified_at?: boolean
    role?: boolean
    hashed_password?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    created_at?: boolean
    modified_at?: boolean
    role?: boolean
    hashed_password?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    created_at?: boolean
    modified_at?: boolean
    role?: boolean
    hashed_password?: boolean
    is_active?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "avatar" | "created_at" | "modified_at" | "role" | "hashed_password" | "is_active", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | User$agentArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    tickets_created?: boolean | User$tickets_createdArgs<ExtArgs>
    tickets_assigned?: boolean | User$tickets_assignedArgs<ExtArgs>
    ticket_comments?: boolean | User$ticket_commentsArgs<ExtArgs>
    ticket_assignments?: boolean | User$ticket_assignmentsArgs<ExtArgs>
    ticket_history?: boolean | User$ticket_historyArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      tickets_created: Prisma.$TicketPayload<ExtArgs>[]
      tickets_assigned: Prisma.$TicketPayload<ExtArgs>[]
      ticket_comments: Prisma.$CommentPayload<ExtArgs>[]
      ticket_assignments: Prisma.$TicketAssignmentPayload<ExtArgs>[]
      ticket_history: Prisma.$TicketHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string | null
      avatar: string | null
      created_at: Date
      modified_at: Date
      role: $Enums.Role
      hashed_password: string
      is_active: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends User$agentArgs<ExtArgs> = {}>(args?: Subset<T, User$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tickets_created<T extends User$tickets_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$tickets_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets_assigned<T extends User$tickets_assignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tickets_assignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticket_comments<T extends User$ticket_commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticket_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticket_assignments<T extends User$ticket_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticket_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticket_history<T extends User$ticket_historyArgs<ExtArgs> = {}>(args?: Subset<T, User$ticket_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly modified_at: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly hashed_password: FieldRef<"User", 'String'>
    readonly is_active: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.agent
   */
  export type User$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.tickets_created
   */
  export type User$tickets_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.tickets_assigned
   */
  export type User$tickets_assignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticket_comments
   */
  export type User$ticket_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.ticket_assignments
   */
  export type User$ticket_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    where?: TicketAssignmentWhereInput
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    cursor?: TicketAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAssignmentScalarFieldEnum | TicketAssignmentScalarFieldEnum[]
  }

  /**
   * User.ticket_history
   */
  export type User$ticket_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    where?: TicketHistoryWhereInput
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    cursor?: TicketHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    max_tickets: number | null
  }

  export type AgentSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    max_tickets: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    employee_id: string | null
    department: string | null
    max_tickets: number | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    employee_id: string | null
    department: string | null
    max_tickets: number | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    user_id: number
    employee_id: number
    department: number
    skills: number
    max_tickets: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    id?: true
    user_id?: true
    max_tickets?: true
  }

  export type AgentSumAggregateInputType = {
    id?: true
    user_id?: true
    max_tickets?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    user_id?: true
    employee_id?: true
    department?: true
    max_tickets?: true
    created_at?: true
    modified_at?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    user_id?: true
    employee_id?: true
    department?: true
    max_tickets?: true
    created_at?: true
    modified_at?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    user_id?: true
    employee_id?: true
    department?: true
    skills?: true
    max_tickets?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: number
    user_id: number
    employee_id: string
    department: string | null
    skills: string[]
    max_tickets: number
    created_at: Date
    modified_at: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    employee_id?: boolean
    department?: boolean
    skills?: boolean
    max_tickets?: boolean
    created_at?: boolean
    modified_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ticket_assignments?: boolean | Agent$ticket_assignmentsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    employee_id?: boolean
    department?: boolean
    skills?: boolean
    max_tickets?: boolean
    created_at?: boolean
    modified_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    employee_id?: boolean
    department?: boolean
    skills?: boolean
    max_tickets?: boolean
    created_at?: boolean
    modified_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    user_id?: boolean
    employee_id?: boolean
    department?: boolean
    skills?: boolean
    max_tickets?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "employee_id" | "department" | "skills" | "max_tickets" | "created_at" | "modified_at", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ticket_assignments?: boolean | Agent$ticket_assignmentsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ticket_assignments: Prisma.$TicketAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      employee_id: string
      department: string | null
      skills: string[]
      max_tickets: number
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket_assignments<T extends Agent$ticket_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ticket_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'Int'>
    readonly user_id: FieldRef<"Agent", 'Int'>
    readonly employee_id: FieldRef<"Agent", 'String'>
    readonly department: FieldRef<"Agent", 'String'>
    readonly skills: FieldRef<"Agent", 'String[]'>
    readonly max_tickets: FieldRef<"Agent", 'Int'>
    readonly created_at: FieldRef<"Agent", 'DateTime'>
    readonly modified_at: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.ticket_assignments
   */
  export type Agent$ticket_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    where?: TicketAssignmentWhereInput
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    cursor?: TicketAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAssignmentScalarFieldEnum | TicketAssignmentScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    company: string | null
    client_type: $Enums.ClientType | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    company: string | null
    client_type: $Enums.ClientType | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    user_id: number
    company: number
    client_type: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    user_id?: true
    company?: true
    client_type?: true
    created_at?: true
    modified_at?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    user_id?: true
    company?: true
    client_type?: true
    created_at?: true
    modified_at?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    user_id?: true
    company?: true
    client_type?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    user_id: number
    company: string | null
    client_type: $Enums.ClientType
    created_at: Date
    modified_at: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company?: boolean
    client_type?: boolean
    created_at?: boolean
    modified_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tickets?: boolean | Client$ticketsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company?: boolean
    client_type?: boolean
    created_at?: boolean
    modified_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company?: boolean
    client_type?: boolean
    created_at?: boolean
    modified_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    user_id?: boolean
    company?: boolean
    client_type?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "company" | "client_type" | "created_at" | "modified_at", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tickets?: boolean | Client$ticketsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      company: string | null
      client_type: $Enums.ClientType
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Client$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Client$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly user_id: FieldRef<"Client", 'Int'>
    readonly company: FieldRef<"Client", 'String'>
    readonly client_type: FieldRef<"Client", 'ClientType'>
    readonly created_at: FieldRef<"Client", 'DateTime'>
    readonly modified_at: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.tickets
   */
  export type Client$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    color: string | null
    icon: string | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    color: string | null
    icon: string | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    icon: number
    is_active: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    icon?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    icon?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    icon?: true
    is_active?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    color: string
    icon: string | null
    is_active: boolean
    created_at: Date
    modified_at: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    tickets?: boolean | Category$ticketsArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    response_templates?: boolean | Category$response_templatesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "icon" | "is_active" | "created_at" | "modified_at", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | Category$ticketsArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    response_templates?: boolean | Category$response_templatesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      subcategories: Prisma.$SubcategoryPayload<ExtArgs>[]
      response_templates: Prisma.$ResponseTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      color: string
      icon: string | null
      is_active: boolean
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends Category$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Category$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Category$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    response_templates<T extends Category$response_templatesArgs<ExtArgs> = {}>(args?: Subset<T, Category$response_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly is_active: FieldRef<"Category", 'Boolean'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
    readonly modified_at: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.tickets
   */
  export type Category$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Category.subcategories
   */
  export type Category$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    cursor?: SubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Category.response_templates
   */
  export type Category$response_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    where?: ResponseTemplateWhereInput
    orderBy?: ResponseTemplateOrderByWithRelationInput | ResponseTemplateOrderByWithRelationInput[]
    cursor?: ResponseTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseTemplateScalarFieldEnum | ResponseTemplateScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Subcategory
   */

  export type AggregateSubcategory = {
    _count: SubcategoryCountAggregateOutputType | null
    _avg: SubcategoryAvgAggregateOutputType | null
    _sum: SubcategorySumAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  export type SubcategoryAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type SubcategorySumAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type SubcategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category_id: number | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type SubcategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category_id: number | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type SubcategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category_id: number
    is_active: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type SubcategoryAvgAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type SubcategorySumAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type SubcategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category_id?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type SubcategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category_id?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type SubcategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category_id?: true
    is_active?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type SubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategory to aggregate.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subcategories
    **/
    _count?: true | SubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubcategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubcategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubcategoryMaxAggregateInputType
  }

  export type GetSubcategoryAggregateType<T extends SubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubcategory[P]>
      : GetScalarType<T[P], AggregateSubcategory[P]>
  }




  export type SubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithAggregationInput | SubcategoryOrderByWithAggregationInput[]
    by: SubcategoryScalarFieldEnum[] | SubcategoryScalarFieldEnum
    having?: SubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubcategoryCountAggregateInputType | true
    _avg?: SubcategoryAvgAggregateInputType
    _sum?: SubcategorySumAggregateInputType
    _min?: SubcategoryMinAggregateInputType
    _max?: SubcategoryMaxAggregateInputType
  }

  export type SubcategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category_id: number
    is_active: boolean
    created_at: Date
    modified_at: Date
    _count: SubcategoryCountAggregateOutputType | null
    _avg: SubcategoryAvgAggregateOutputType | null
    _sum: SubcategorySumAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  type GetSubcategoryGroupByPayload<T extends SubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    tickets?: boolean | Subcategory$ticketsArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type SubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category_id" | "is_active" | "created_at" | "modified_at", ExtArgs["result"]["subcategory"]>
  export type SubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    tickets?: boolean | Subcategory$ticketsArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $SubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subcategory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category_id: number
      is_active: boolean
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["subcategory"]>
    composites: {}
  }

  type SubcategoryGetPayload<S extends boolean | null | undefined | SubcategoryDefaultArgs> = $Result.GetResult<Prisma.$SubcategoryPayload, S>

  type SubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubcategoryCountAggregateInputType | true
    }

  export interface SubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subcategory'], meta: { name: 'Subcategory' } }
    /**
     * Find zero or one Subcategory that matches the filter.
     * @param {SubcategoryFindUniqueArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubcategoryFindUniqueArgs>(args: SelectSubset<T, SubcategoryFindUniqueArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubcategoryFindUniqueOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubcategoryFindFirstArgs>(args?: SelectSubset<T, SubcategoryFindFirstArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subcategories
     * const subcategories = await prisma.subcategory.findMany()
     * 
     * // Get first 10 Subcategories
     * const subcategories = await prisma.subcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubcategoryFindManyArgs>(args?: SelectSubset<T, SubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subcategory.
     * @param {SubcategoryCreateArgs} args - Arguments to create a Subcategory.
     * @example
     * // Create one Subcategory
     * const Subcategory = await prisma.subcategory.create({
     *   data: {
     *     // ... data to create a Subcategory
     *   }
     * })
     * 
     */
    create<T extends SubcategoryCreateArgs>(args: SelectSubset<T, SubcategoryCreateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subcategories.
     * @param {SubcategoryCreateManyArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubcategoryCreateManyArgs>(args?: SelectSubset<T, SubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subcategories and returns the data saved in the database.
     * @param {SubcategoryCreateManyAndReturnArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subcategory.
     * @param {SubcategoryDeleteArgs} args - Arguments to delete one Subcategory.
     * @example
     * // Delete one Subcategory
     * const Subcategory = await prisma.subcategory.delete({
     *   where: {
     *     // ... filter to delete one Subcategory
     *   }
     * })
     * 
     */
    delete<T extends SubcategoryDeleteArgs>(args: SelectSubset<T, SubcategoryDeleteArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subcategory.
     * @param {SubcategoryUpdateArgs} args - Arguments to update one Subcategory.
     * @example
     * // Update one Subcategory
     * const subcategory = await prisma.subcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubcategoryUpdateArgs>(args: SelectSubset<T, SubcategoryUpdateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subcategories.
     * @param {SubcategoryDeleteManyArgs} args - Arguments to filter Subcategories to delete.
     * @example
     * // Delete a few Subcategories
     * const { count } = await prisma.subcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubcategoryDeleteManyArgs>(args?: SelectSubset<T, SubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubcategoryUpdateManyArgs>(args: SelectSubset<T, SubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories and returns the data updated in the database.
     * @param {SubcategoryUpdateManyAndReturnArgs} args - Arguments to update many Subcategories.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subcategory.
     * @param {SubcategoryUpsertArgs} args - Arguments to update or create a Subcategory.
     * @example
     * // Update or create a Subcategory
     * const subcategory = await prisma.subcategory.upsert({
     *   create: {
     *     // ... data to create a Subcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subcategory we want to update
     *   }
     * })
     */
    upsert<T extends SubcategoryUpsertArgs>(args: SelectSubset<T, SubcategoryUpsertArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryCountArgs} args - Arguments to filter Subcategories to count.
     * @example
     * // Count the number of Subcategories
     * const count = await prisma.subcategory.count({
     *   where: {
     *     // ... the filter for the Subcategories we want to count
     *   }
     * })
    **/
    count<T extends SubcategoryCountArgs>(
      args?: Subset<T, SubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubcategoryAggregateArgs>(args: Subset<T, SubcategoryAggregateArgs>): Prisma.PrismaPromise<GetSubcategoryAggregateType<T>>

    /**
     * Group by Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subcategory model
   */
  readonly fields: SubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Subcategory$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subcategory model
   */
  interface SubcategoryFieldRefs {
    readonly id: FieldRef<"Subcategory", 'Int'>
    readonly name: FieldRef<"Subcategory", 'String'>
    readonly description: FieldRef<"Subcategory", 'String'>
    readonly category_id: FieldRef<"Subcategory", 'Int'>
    readonly is_active: FieldRef<"Subcategory", 'Boolean'>
    readonly created_at: FieldRef<"Subcategory", 'DateTime'>
    readonly modified_at: FieldRef<"Subcategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subcategory findUnique
   */
  export type SubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findUniqueOrThrow
   */
  export type SubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findFirst
   */
  export type SubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findFirstOrThrow
   */
  export type SubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findMany
   */
  export type SubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategories to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory create
   */
  export type SubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Subcategory.
     */
    data: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
  }

  /**
   * Subcategory createMany
   */
  export type SubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subcategory createManyAndReturn
   */
  export type SubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory update
   */
  export type SubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Subcategory.
     */
    data: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
    /**
     * Choose, which Subcategory to update.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory updateMany
   */
  export type SubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
  }

  /**
   * Subcategory updateManyAndReturn
   */
  export type SubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory upsert
   */
  export type SubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Subcategory to update in case it exists.
     */
    where: SubcategoryWhereUniqueInput
    /**
     * In case the Subcategory found by the `where` argument doesn't exist, create a new Subcategory with this data.
     */
    create: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
    /**
     * In case the Subcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
  }

  /**
   * Subcategory delete
   */
  export type SubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter which Subcategory to delete.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory deleteMany
   */
  export type SubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategories to delete
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to delete.
     */
    limit?: number
  }

  /**
   * Subcategory.tickets
   */
  export type Subcategory$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Subcategory without action
   */
  export type SubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
    subcategory_id: number | null
    client_id: number | null
    created_by: number | null
    assigned_to: number | null
    resolution_time: number | null
    satisfaction_rating: number | null
  }

  export type TicketSumAggregateOutputType = {
    id: number | null
    category_id: number | null
    subcategory_id: number | null
    client_id: number | null
    created_by: number | null
    assigned_to: number | null
    resolution_time: number | null
    satisfaction_rating: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: number | null
    ticket_number: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    status: $Enums.TicketStatus | null
    category_id: number | null
    subcategory_id: number | null
    client_id: number | null
    created_by: number | null
    assigned_to: number | null
    due_date: Date | null
    resolution_time: number | null
    satisfaction_rating: number | null
    created_at: Date | null
    modified_at: Date | null
    closed_at: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: number | null
    ticket_number: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    status: $Enums.TicketStatus | null
    category_id: number | null
    subcategory_id: number | null
    client_id: number | null
    created_by: number | null
    assigned_to: number | null
    due_date: Date | null
    resolution_time: number | null
    satisfaction_rating: number | null
    created_at: Date | null
    modified_at: Date | null
    closed_at: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    ticket_number: number
    title: number
    description: number
    priority: number
    status: number
    category_id: number
    subcategory_id: number
    client_id: number
    created_by: number
    assigned_to: number
    due_date: number
    resolution_time: number
    satisfaction_rating: number
    created_at: number
    modified_at: number
    closed_at: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    id?: true
    category_id?: true
    subcategory_id?: true
    client_id?: true
    created_by?: true
    assigned_to?: true
    resolution_time?: true
    satisfaction_rating?: true
  }

  export type TicketSumAggregateInputType = {
    id?: true
    category_id?: true
    subcategory_id?: true
    client_id?: true
    created_by?: true
    assigned_to?: true
    resolution_time?: true
    satisfaction_rating?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    ticket_number?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    category_id?: true
    subcategory_id?: true
    client_id?: true
    created_by?: true
    assigned_to?: true
    due_date?: true
    resolution_time?: true
    satisfaction_rating?: true
    created_at?: true
    modified_at?: true
    closed_at?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    ticket_number?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    category_id?: true
    subcategory_id?: true
    client_id?: true
    created_by?: true
    assigned_to?: true
    due_date?: true
    resolution_time?: true
    satisfaction_rating?: true
    created_at?: true
    modified_at?: true
    closed_at?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    ticket_number?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    category_id?: true
    subcategory_id?: true
    client_id?: true
    created_by?: true
    assigned_to?: true
    due_date?: true
    resolution_time?: true
    satisfaction_rating?: true
    created_at?: true
    modified_at?: true
    closed_at?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: number
    ticket_number: string
    title: string
    description: string
    priority: $Enums.Priority
    status: $Enums.TicketStatus
    category_id: number
    subcategory_id: number | null
    client_id: number
    created_by: number
    assigned_to: number | null
    due_date: Date | null
    resolution_time: number | null
    satisfaction_rating: number | null
    created_at: Date
    modified_at: Date
    closed_at: Date | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_number?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    category_id?: boolean
    subcategory_id?: boolean
    client_id?: boolean
    created_by?: boolean
    assigned_to?: boolean
    due_date?: boolean
    resolution_time?: boolean
    satisfaction_rating?: boolean
    created_at?: boolean
    modified_at?: boolean
    closed_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Ticket$subcategoryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    ticket_history?: boolean | Ticket$ticket_historyArgs<ExtArgs>
    ticket_assignments?: boolean | Ticket$ticket_assignmentsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_number?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    category_id?: boolean
    subcategory_id?: boolean
    client_id?: boolean
    created_by?: boolean
    assigned_to?: boolean
    due_date?: boolean
    resolution_time?: boolean
    satisfaction_rating?: boolean
    created_at?: boolean
    modified_at?: boolean
    closed_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Ticket$subcategoryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_number?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    category_id?: boolean
    subcategory_id?: boolean
    client_id?: boolean
    created_by?: boolean
    assigned_to?: boolean
    due_date?: boolean
    resolution_time?: boolean
    satisfaction_rating?: boolean
    created_at?: boolean
    modified_at?: boolean
    closed_at?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Ticket$subcategoryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    ticket_number?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    category_id?: boolean
    subcategory_id?: boolean
    client_id?: boolean
    created_by?: boolean
    assigned_to?: boolean
    due_date?: boolean
    resolution_time?: boolean
    satisfaction_rating?: boolean
    created_at?: boolean
    modified_at?: boolean
    closed_at?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_number" | "title" | "description" | "priority" | "status" | "category_id" | "subcategory_id" | "client_id" | "created_by" | "assigned_to" | "due_date" | "resolution_time" | "satisfaction_rating" | "created_at" | "modified_at" | "closed_at", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Ticket$subcategoryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    ticket_history?: boolean | Ticket$ticket_historyArgs<ExtArgs>
    ticket_assignments?: boolean | Ticket$ticket_assignmentsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Ticket$subcategoryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Ticket$subcategoryArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Ticket$assigneeArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      subcategory: Prisma.$SubcategoryPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      ticket_history: Prisma.$TicketHistoryPayload<ExtArgs>[]
      ticket_assignments: Prisma.$TicketAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_number: string
      title: string
      description: string
      priority: $Enums.Priority
      status: $Enums.TicketStatus
      category_id: number
      subcategory_id: number | null
      client_id: number
      created_by: number
      assigned_to: number | null
      due_date: Date | null
      resolution_time: number | null
      satisfaction_rating: number | null
      created_at: Date
      modified_at: Date
      closed_at: Date | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends Ticket$subcategoryArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$subcategoryArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Ticket$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Ticket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Ticket$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticket_history<T extends Ticket$ticket_historyArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$ticket_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticket_assignments<T extends Ticket$ticket_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$ticket_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'Int'>
    readonly ticket_number: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly priority: FieldRef<"Ticket", 'Priority'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly category_id: FieldRef<"Ticket", 'Int'>
    readonly subcategory_id: FieldRef<"Ticket", 'Int'>
    readonly client_id: FieldRef<"Ticket", 'Int'>
    readonly created_by: FieldRef<"Ticket", 'Int'>
    readonly assigned_to: FieldRef<"Ticket", 'Int'>
    readonly due_date: FieldRef<"Ticket", 'DateTime'>
    readonly resolution_time: FieldRef<"Ticket", 'Int'>
    readonly satisfaction_rating: FieldRef<"Ticket", 'Int'>
    readonly created_at: FieldRef<"Ticket", 'DateTime'>
    readonly modified_at: FieldRef<"Ticket", 'DateTime'>
    readonly closed_at: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.subcategory
   */
  export type Ticket$subcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
  }

  /**
   * Ticket.assignee
   */
  export type Ticket$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.comments
   */
  export type Ticket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Ticket.attachments
   */
  export type Ticket$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Ticket.ticket_history
   */
  export type Ticket$ticket_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    where?: TicketHistoryWhereInput
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    cursor?: TicketHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * Ticket.ticket_assignments
   */
  export type Ticket$ticket_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    where?: TicketAssignmentWhereInput
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    cursor?: TicketAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAssignmentScalarFieldEnum | TicketAssignmentScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    user_id: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    user_id: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    user_id: number | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    user_id: number | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    ticket_id: number
    user_id: number
    content: number
    is_internal: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    ticket_id?: true
    user_id?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    ticket_id?: true
    user_id?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    ticket_id?: true
    user_id?: true
    content?: true
    is_internal?: true
    created_at?: true
    modified_at?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    user_id?: true
    content?: true
    is_internal?: true
    created_at?: true
    modified_at?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    ticket_id?: true
    user_id?: true
    content?: true
    is_internal?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    ticket_id: number
    user_id: number
    content: string
    is_internal: boolean
    created_at: Date
    modified_at: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    user_id?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
    modified_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Comment$attachmentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    user_id?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
    modified_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    user_id?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
    modified_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    user_id?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "user_id" | "content" | "is_internal" | "created_at" | "modified_at", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Comment$attachmentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      user_id: number
      content: string
      is_internal: boolean
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Comment$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly ticket_id: FieldRef<"Comment", 'Int'>
    readonly user_id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly is_internal: FieldRef<"Comment", 'Boolean'>
    readonly created_at: FieldRef<"Comment", 'DateTime'>
    readonly modified_at: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.attachments
   */
  export type Comment$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    id: number | null
    file_size: number | null
    ticket_id: number | null
    comment_id: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    id: number | null
    file_size: number | null
    ticket_id: number | null
    comment_id: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: number | null
    filename: string | null
    original_name: string | null
    file_path: string | null
    file_size: number | null
    mime_type: string | null
    ticket_id: number | null
    comment_id: number | null
    created_at: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    original_name: string | null
    file_path: string | null
    file_size: number | null
    mime_type: string | null
    ticket_id: number | null
    comment_id: number | null
    created_at: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    filename: number
    original_name: number
    file_path: number
    file_size: number
    mime_type: number
    ticket_id: number
    comment_id: number
    created_at: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    id?: true
    file_size?: true
    ticket_id?: true
    comment_id?: true
  }

  export type AttachmentSumAggregateInputType = {
    id?: true
    file_size?: true
    ticket_id?: true
    comment_id?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    filename?: true
    original_name?: true
    file_path?: true
    file_size?: true
    mime_type?: true
    ticket_id?: true
    comment_id?: true
    created_at?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    filename?: true
    original_name?: true
    file_path?: true
    file_size?: true
    mime_type?: true
    ticket_id?: true
    comment_id?: true
    created_at?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    filename?: true
    original_name?: true
    file_path?: true
    file_size?: true
    mime_type?: true
    ticket_id?: true
    comment_id?: true
    created_at?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    ticket_id: number | null
    comment_id: number | null
    created_at: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    original_name?: boolean
    file_path?: boolean
    file_size?: boolean
    mime_type?: boolean
    ticket_id?: boolean
    comment_id?: boolean
    created_at?: boolean
    ticket?: boolean | Attachment$ticketArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    original_name?: boolean
    file_path?: boolean
    file_size?: boolean
    mime_type?: boolean
    ticket_id?: boolean
    comment_id?: boolean
    created_at?: boolean
    ticket?: boolean | Attachment$ticketArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    original_name?: boolean
    file_path?: boolean
    file_size?: boolean
    mime_type?: boolean
    ticket_id?: boolean
    comment_id?: boolean
    created_at?: boolean
    ticket?: boolean | Attachment$ticketArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    filename?: boolean
    original_name?: boolean
    file_path?: boolean
    file_size?: boolean
    mime_type?: boolean
    ticket_id?: boolean
    comment_id?: boolean
    created_at?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "original_name" | "file_path" | "file_size" | "mime_type" | "ticket_id" | "comment_id" | "created_at", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | Attachment$ticketArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | Attachment$ticketArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | Attachment$ticketArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      original_name: string
      file_path: string
      file_size: number
      mime_type: string
      ticket_id: number | null
      comment_id: number | null
      created_at: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends Attachment$ticketArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$ticketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Attachment$commentArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'Int'>
    readonly filename: FieldRef<"Attachment", 'String'>
    readonly original_name: FieldRef<"Attachment", 'String'>
    readonly file_path: FieldRef<"Attachment", 'String'>
    readonly file_size: FieldRef<"Attachment", 'Int'>
    readonly mime_type: FieldRef<"Attachment", 'String'>
    readonly ticket_id: FieldRef<"Attachment", 'Int'>
    readonly comment_id: FieldRef<"Attachment", 'Int'>
    readonly created_at: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment.ticket
   */
  export type Attachment$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * Attachment.comment
   */
  export type Attachment$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TicketHistory
   */

  export type AggregateTicketHistory = {
    _count: TicketHistoryCountAggregateOutputType | null
    _avg: TicketHistoryAvgAggregateOutputType | null
    _sum: TicketHistorySumAggregateOutputType | null
    _min: TicketHistoryMinAggregateOutputType | null
    _max: TicketHistoryMaxAggregateOutputType | null
  }

  export type TicketHistoryAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    changed_by: number | null
  }

  export type TicketHistorySumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    changed_by: number | null
  }

  export type TicketHistoryMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    field_name: string | null
    old_value: string | null
    new_value: string | null
    changed_by: number | null
    created_at: Date | null
  }

  export type TicketHistoryMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    field_name: string | null
    old_value: string | null
    new_value: string | null
    changed_by: number | null
    created_at: Date | null
  }

  export type TicketHistoryCountAggregateOutputType = {
    id: number
    ticket_id: number
    field_name: number
    old_value: number
    new_value: number
    changed_by: number
    created_at: number
    _all: number
  }


  export type TicketHistoryAvgAggregateInputType = {
    id?: true
    ticket_id?: true
    changed_by?: true
  }

  export type TicketHistorySumAggregateInputType = {
    id?: true
    ticket_id?: true
    changed_by?: true
  }

  export type TicketHistoryMinAggregateInputType = {
    id?: true
    ticket_id?: true
    field_name?: true
    old_value?: true
    new_value?: true
    changed_by?: true
    created_at?: true
  }

  export type TicketHistoryMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    field_name?: true
    old_value?: true
    new_value?: true
    changed_by?: true
    created_at?: true
  }

  export type TicketHistoryCountAggregateInputType = {
    id?: true
    ticket_id?: true
    field_name?: true
    old_value?: true
    new_value?: true
    changed_by?: true
    created_at?: true
    _all?: true
  }

  export type TicketHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketHistory to aggregate.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketHistories
    **/
    _count?: true | TicketHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketHistoryMaxAggregateInputType
  }

  export type GetTicketHistoryAggregateType<T extends TicketHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketHistory[P]>
      : GetScalarType<T[P], AggregateTicketHistory[P]>
  }




  export type TicketHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketHistoryWhereInput
    orderBy?: TicketHistoryOrderByWithAggregationInput | TicketHistoryOrderByWithAggregationInput[]
    by: TicketHistoryScalarFieldEnum[] | TicketHistoryScalarFieldEnum
    having?: TicketHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketHistoryCountAggregateInputType | true
    _avg?: TicketHistoryAvgAggregateInputType
    _sum?: TicketHistorySumAggregateInputType
    _min?: TicketHistoryMinAggregateInputType
    _max?: TicketHistoryMaxAggregateInputType
  }

  export type TicketHistoryGroupByOutputType = {
    id: number
    ticket_id: number
    field_name: string
    old_value: string | null
    new_value: string | null
    changed_by: number
    created_at: Date
    _count: TicketHistoryCountAggregateOutputType | null
    _avg: TicketHistoryAvgAggregateOutputType | null
    _sum: TicketHistorySumAggregateOutputType | null
    _min: TicketHistoryMinAggregateOutputType | null
    _max: TicketHistoryMaxAggregateOutputType | null
  }

  type GetTicketHistoryGroupByPayload<T extends TicketHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TicketHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TicketHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    field_name?: boolean
    old_value?: boolean
    new_value?: boolean
    changed_by?: boolean
    created_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketHistory"]>

  export type TicketHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    field_name?: boolean
    old_value?: boolean
    new_value?: boolean
    changed_by?: boolean
    created_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketHistory"]>

  export type TicketHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    field_name?: boolean
    old_value?: boolean
    new_value?: boolean
    changed_by?: boolean
    created_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketHistory"]>

  export type TicketHistorySelectScalar = {
    id?: boolean
    ticket_id?: boolean
    field_name?: boolean
    old_value?: boolean
    new_value?: boolean
    changed_by?: boolean
    created_at?: boolean
  }

  export type TicketHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "field_name" | "old_value" | "new_value" | "changed_by" | "created_at", ExtArgs["result"]["ticketHistory"]>
  export type TicketHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketHistory"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      field_name: string
      old_value: string | null
      new_value: string | null
      changed_by: number
      created_at: Date
    }, ExtArgs["result"]["ticketHistory"]>
    composites: {}
  }

  type TicketHistoryGetPayload<S extends boolean | null | undefined | TicketHistoryDefaultArgs> = $Result.GetResult<Prisma.$TicketHistoryPayload, S>

  type TicketHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketHistoryCountAggregateInputType | true
    }

  export interface TicketHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketHistory'], meta: { name: 'TicketHistory' } }
    /**
     * Find zero or one TicketHistory that matches the filter.
     * @param {TicketHistoryFindUniqueArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketHistoryFindUniqueArgs>(args: SelectSubset<T, TicketHistoryFindUniqueArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketHistoryFindUniqueOrThrowArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryFindFirstArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketHistoryFindFirstArgs>(args?: SelectSubset<T, TicketHistoryFindFirstArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryFindFirstOrThrowArgs} args - Arguments to find a TicketHistory
     * @example
     * // Get one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketHistories
     * const ticketHistories = await prisma.ticketHistory.findMany()
     * 
     * // Get first 10 TicketHistories
     * const ticketHistories = await prisma.ticketHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketHistoryWithIdOnly = await prisma.ticketHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketHistoryFindManyArgs>(args?: SelectSubset<T, TicketHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketHistory.
     * @param {TicketHistoryCreateArgs} args - Arguments to create a TicketHistory.
     * @example
     * // Create one TicketHistory
     * const TicketHistory = await prisma.ticketHistory.create({
     *   data: {
     *     // ... data to create a TicketHistory
     *   }
     * })
     * 
     */
    create<T extends TicketHistoryCreateArgs>(args: SelectSubset<T, TicketHistoryCreateArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketHistories.
     * @param {TicketHistoryCreateManyArgs} args - Arguments to create many TicketHistories.
     * @example
     * // Create many TicketHistories
     * const ticketHistory = await prisma.ticketHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketHistoryCreateManyArgs>(args?: SelectSubset<T, TicketHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketHistories and returns the data saved in the database.
     * @param {TicketHistoryCreateManyAndReturnArgs} args - Arguments to create many TicketHistories.
     * @example
     * // Create many TicketHistories
     * const ticketHistory = await prisma.ticketHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketHistories and only return the `id`
     * const ticketHistoryWithIdOnly = await prisma.ticketHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketHistory.
     * @param {TicketHistoryDeleteArgs} args - Arguments to delete one TicketHistory.
     * @example
     * // Delete one TicketHistory
     * const TicketHistory = await prisma.ticketHistory.delete({
     *   where: {
     *     // ... filter to delete one TicketHistory
     *   }
     * })
     * 
     */
    delete<T extends TicketHistoryDeleteArgs>(args: SelectSubset<T, TicketHistoryDeleteArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketHistory.
     * @param {TicketHistoryUpdateArgs} args - Arguments to update one TicketHistory.
     * @example
     * // Update one TicketHistory
     * const ticketHistory = await prisma.ticketHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketHistoryUpdateArgs>(args: SelectSubset<T, TicketHistoryUpdateArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketHistories.
     * @param {TicketHistoryDeleteManyArgs} args - Arguments to filter TicketHistories to delete.
     * @example
     * // Delete a few TicketHistories
     * const { count } = await prisma.ticketHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketHistoryDeleteManyArgs>(args?: SelectSubset<T, TicketHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketHistories
     * const ticketHistory = await prisma.ticketHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketHistoryUpdateManyArgs>(args: SelectSubset<T, TicketHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketHistories and returns the data updated in the database.
     * @param {TicketHistoryUpdateManyAndReturnArgs} args - Arguments to update many TicketHistories.
     * @example
     * // Update many TicketHistories
     * const ticketHistory = await prisma.ticketHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketHistories and only return the `id`
     * const ticketHistoryWithIdOnly = await prisma.ticketHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketHistory.
     * @param {TicketHistoryUpsertArgs} args - Arguments to update or create a TicketHistory.
     * @example
     * // Update or create a TicketHistory
     * const ticketHistory = await prisma.ticketHistory.upsert({
     *   create: {
     *     // ... data to create a TicketHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketHistory we want to update
     *   }
     * })
     */
    upsert<T extends TicketHistoryUpsertArgs>(args: SelectSubset<T, TicketHistoryUpsertArgs<ExtArgs>>): Prisma__TicketHistoryClient<$Result.GetResult<Prisma.$TicketHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryCountArgs} args - Arguments to filter TicketHistories to count.
     * @example
     * // Count the number of TicketHistories
     * const count = await prisma.ticketHistory.count({
     *   where: {
     *     // ... the filter for the TicketHistories we want to count
     *   }
     * })
    **/
    count<T extends TicketHistoryCountArgs>(
      args?: Subset<T, TicketHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketHistoryAggregateArgs>(args: Subset<T, TicketHistoryAggregateArgs>): Prisma.PrismaPromise<GetTicketHistoryAggregateType<T>>

    /**
     * Group by TicketHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TicketHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketHistory model
   */
  readonly fields: TicketHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketHistory model
   */
  interface TicketHistoryFieldRefs {
    readonly id: FieldRef<"TicketHistory", 'Int'>
    readonly ticket_id: FieldRef<"TicketHistory", 'Int'>
    readonly field_name: FieldRef<"TicketHistory", 'String'>
    readonly old_value: FieldRef<"TicketHistory", 'String'>
    readonly new_value: FieldRef<"TicketHistory", 'String'>
    readonly changed_by: FieldRef<"TicketHistory", 'Int'>
    readonly created_at: FieldRef<"TicketHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketHistory findUnique
   */
  export type TicketHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory findUniqueOrThrow
   */
  export type TicketHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory findFirst
   */
  export type TicketHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketHistories.
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketHistories.
     */
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * TicketHistory findFirstOrThrow
   */
  export type TicketHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistory to fetch.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketHistories.
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketHistories.
     */
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * TicketHistory findMany
   */
  export type TicketHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketHistories to fetch.
     */
    where?: TicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketHistories to fetch.
     */
    orderBy?: TicketHistoryOrderByWithRelationInput | TicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketHistories.
     */
    cursor?: TicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketHistories.
     */
    skip?: number
    distinct?: TicketHistoryScalarFieldEnum | TicketHistoryScalarFieldEnum[]
  }

  /**
   * TicketHistory create
   */
  export type TicketHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketHistory.
     */
    data: XOR<TicketHistoryCreateInput, TicketHistoryUncheckedCreateInput>
  }

  /**
   * TicketHistory createMany
   */
  export type TicketHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketHistories.
     */
    data: TicketHistoryCreateManyInput | TicketHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketHistory createManyAndReturn
   */
  export type TicketHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many TicketHistories.
     */
    data: TicketHistoryCreateManyInput | TicketHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketHistory update
   */
  export type TicketHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketHistory.
     */
    data: XOR<TicketHistoryUpdateInput, TicketHistoryUncheckedUpdateInput>
    /**
     * Choose, which TicketHistory to update.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory updateMany
   */
  export type TicketHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketHistories.
     */
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TicketHistories to update
     */
    where?: TicketHistoryWhereInput
    /**
     * Limit how many TicketHistories to update.
     */
    limit?: number
  }

  /**
   * TicketHistory updateManyAndReturn
   */
  export type TicketHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * The data used to update TicketHistories.
     */
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TicketHistories to update
     */
    where?: TicketHistoryWhereInput
    /**
     * Limit how many TicketHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketHistory upsert
   */
  export type TicketHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketHistory to update in case it exists.
     */
    where: TicketHistoryWhereUniqueInput
    /**
     * In case the TicketHistory found by the `where` argument doesn't exist, create a new TicketHistory with this data.
     */
    create: XOR<TicketHistoryCreateInput, TicketHistoryUncheckedCreateInput>
    /**
     * In case the TicketHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketHistoryUpdateInput, TicketHistoryUncheckedUpdateInput>
  }

  /**
   * TicketHistory delete
   */
  export type TicketHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
    /**
     * Filter which TicketHistory to delete.
     */
    where: TicketHistoryWhereUniqueInput
  }

  /**
   * TicketHistory deleteMany
   */
  export type TicketHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketHistories to delete
     */
    where?: TicketHistoryWhereInput
    /**
     * Limit how many TicketHistories to delete.
     */
    limit?: number
  }

  /**
   * TicketHistory without action
   */
  export type TicketHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketHistory
     */
    select?: TicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketHistory
     */
    omit?: TicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketHistoryInclude<ExtArgs> | null
  }


  /**
   * Model TicketAssignment
   */

  export type AggregateTicketAssignment = {
    _count: TicketAssignmentCountAggregateOutputType | null
    _avg: TicketAssignmentAvgAggregateOutputType | null
    _sum: TicketAssignmentSumAggregateOutputType | null
    _min: TicketAssignmentMinAggregateOutputType | null
    _max: TicketAssignmentMaxAggregateOutputType | null
  }

  export type TicketAssignmentAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    agent_id: number | null
    assigned_by: number | null
  }

  export type TicketAssignmentSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    agent_id: number | null
    assigned_by: number | null
  }

  export type TicketAssignmentMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    agent_id: number | null
    assigned_by: number | null
    assigned_at: Date | null
    unassigned_at: Date | null
  }

  export type TicketAssignmentMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    agent_id: number | null
    assigned_by: number | null
    assigned_at: Date | null
    unassigned_at: Date | null
  }

  export type TicketAssignmentCountAggregateOutputType = {
    id: number
    ticket_id: number
    agent_id: number
    assigned_by: number
    assigned_at: number
    unassigned_at: number
    _all: number
  }


  export type TicketAssignmentAvgAggregateInputType = {
    id?: true
    ticket_id?: true
    agent_id?: true
    assigned_by?: true
  }

  export type TicketAssignmentSumAggregateInputType = {
    id?: true
    ticket_id?: true
    agent_id?: true
    assigned_by?: true
  }

  export type TicketAssignmentMinAggregateInputType = {
    id?: true
    ticket_id?: true
    agent_id?: true
    assigned_by?: true
    assigned_at?: true
    unassigned_at?: true
  }

  export type TicketAssignmentMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    agent_id?: true
    assigned_by?: true
    assigned_at?: true
    unassigned_at?: true
  }

  export type TicketAssignmentCountAggregateInputType = {
    id?: true
    ticket_id?: true
    agent_id?: true
    assigned_by?: true
    assigned_at?: true
    unassigned_at?: true
    _all?: true
  }

  export type TicketAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAssignment to aggregate.
     */
    where?: TicketAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAssignments to fetch.
     */
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAssignments
    **/
    _count?: true | TicketAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAssignmentMaxAggregateInputType
  }

  export type GetTicketAssignmentAggregateType<T extends TicketAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAssignment[P]>
      : GetScalarType<T[P], AggregateTicketAssignment[P]>
  }




  export type TicketAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAssignmentWhereInput
    orderBy?: TicketAssignmentOrderByWithAggregationInput | TicketAssignmentOrderByWithAggregationInput[]
    by: TicketAssignmentScalarFieldEnum[] | TicketAssignmentScalarFieldEnum
    having?: TicketAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAssignmentCountAggregateInputType | true
    _avg?: TicketAssignmentAvgAggregateInputType
    _sum?: TicketAssignmentSumAggregateInputType
    _min?: TicketAssignmentMinAggregateInputType
    _max?: TicketAssignmentMaxAggregateInputType
  }

  export type TicketAssignmentGroupByOutputType = {
    id: number
    ticket_id: number
    agent_id: number
    assigned_by: number
    assigned_at: Date
    unassigned_at: Date | null
    _count: TicketAssignmentCountAggregateOutputType | null
    _avg: TicketAssignmentAvgAggregateOutputType | null
    _sum: TicketAssignmentSumAggregateOutputType | null
    _min: TicketAssignmentMinAggregateOutputType | null
    _max: TicketAssignmentMaxAggregateOutputType | null
  }

  type GetTicketAssignmentGroupByPayload<T extends TicketAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    agent_id?: boolean
    assigned_by?: boolean
    assigned_at?: boolean
    unassigned_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    assigned_by_user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAssignment"]>

  export type TicketAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    agent_id?: boolean
    assigned_by?: boolean
    assigned_at?: boolean
    unassigned_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    assigned_by_user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAssignment"]>

  export type TicketAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    agent_id?: boolean
    assigned_by?: boolean
    assigned_at?: boolean
    unassigned_at?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    assigned_by_user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAssignment"]>

  export type TicketAssignmentSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    agent_id?: boolean
    assigned_by?: boolean
    assigned_at?: boolean
    unassigned_at?: boolean
  }

  export type TicketAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "agent_id" | "assigned_by" | "assigned_at" | "unassigned_at", ExtArgs["result"]["ticketAssignment"]>
  export type TicketAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    assigned_by_user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    assigned_by_user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    assigned_by_user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAssignment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      assigned_by_user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      agent_id: number
      assigned_by: number
      assigned_at: Date
      unassigned_at: Date | null
    }, ExtArgs["result"]["ticketAssignment"]>
    composites: {}
  }

  type TicketAssignmentGetPayload<S extends boolean | null | undefined | TicketAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAssignmentPayload, S>

  type TicketAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketAssignmentCountAggregateInputType | true
    }

  export interface TicketAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAssignment'], meta: { name: 'TicketAssignment' } }
    /**
     * Find zero or one TicketAssignment that matches the filter.
     * @param {TicketAssignmentFindUniqueArgs} args - Arguments to find a TicketAssignment
     * @example
     * // Get one TicketAssignment
     * const ticketAssignment = await prisma.ticketAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAssignmentFindUniqueArgs>(args: SelectSubset<T, TicketAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAssignment
     * @example
     * // Get one TicketAssignment
     * const ticketAssignment = await prisma.ticketAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentFindFirstArgs} args - Arguments to find a TicketAssignment
     * @example
     * // Get one TicketAssignment
     * const ticketAssignment = await prisma.ticketAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAssignmentFindFirstArgs>(args?: SelectSubset<T, TicketAssignmentFindFirstArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentFindFirstOrThrowArgs} args - Arguments to find a TicketAssignment
     * @example
     * // Get one TicketAssignment
     * const ticketAssignment = await prisma.ticketAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAssignments
     * const ticketAssignments = await prisma.ticketAssignment.findMany()
     * 
     * // Get first 10 TicketAssignments
     * const ticketAssignments = await prisma.ticketAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAssignmentWithIdOnly = await prisma.ticketAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAssignmentFindManyArgs>(args?: SelectSubset<T, TicketAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketAssignment.
     * @param {TicketAssignmentCreateArgs} args - Arguments to create a TicketAssignment.
     * @example
     * // Create one TicketAssignment
     * const TicketAssignment = await prisma.ticketAssignment.create({
     *   data: {
     *     // ... data to create a TicketAssignment
     *   }
     * })
     * 
     */
    create<T extends TicketAssignmentCreateArgs>(args: SelectSubset<T, TicketAssignmentCreateArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketAssignments.
     * @param {TicketAssignmentCreateManyArgs} args - Arguments to create many TicketAssignments.
     * @example
     * // Create many TicketAssignments
     * const ticketAssignment = await prisma.ticketAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAssignmentCreateManyArgs>(args?: SelectSubset<T, TicketAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketAssignments and returns the data saved in the database.
     * @param {TicketAssignmentCreateManyAndReturnArgs} args - Arguments to create many TicketAssignments.
     * @example
     * // Create many TicketAssignments
     * const ticketAssignment = await prisma.ticketAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketAssignments and only return the `id`
     * const ticketAssignmentWithIdOnly = await prisma.ticketAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketAssignment.
     * @param {TicketAssignmentDeleteArgs} args - Arguments to delete one TicketAssignment.
     * @example
     * // Delete one TicketAssignment
     * const TicketAssignment = await prisma.ticketAssignment.delete({
     *   where: {
     *     // ... filter to delete one TicketAssignment
     *   }
     * })
     * 
     */
    delete<T extends TicketAssignmentDeleteArgs>(args: SelectSubset<T, TicketAssignmentDeleteArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketAssignment.
     * @param {TicketAssignmentUpdateArgs} args - Arguments to update one TicketAssignment.
     * @example
     * // Update one TicketAssignment
     * const ticketAssignment = await prisma.ticketAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAssignmentUpdateArgs>(args: SelectSubset<T, TicketAssignmentUpdateArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketAssignments.
     * @param {TicketAssignmentDeleteManyArgs} args - Arguments to filter TicketAssignments to delete.
     * @example
     * // Delete a few TicketAssignments
     * const { count } = await prisma.ticketAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAssignmentDeleteManyArgs>(args?: SelectSubset<T, TicketAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAssignments
     * const ticketAssignment = await prisma.ticketAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAssignmentUpdateManyArgs>(args: SelectSubset<T, TicketAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAssignments and returns the data updated in the database.
     * @param {TicketAssignmentUpdateManyAndReturnArgs} args - Arguments to update many TicketAssignments.
     * @example
     * // Update many TicketAssignments
     * const ticketAssignment = await prisma.ticketAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketAssignments and only return the `id`
     * const ticketAssignmentWithIdOnly = await prisma.ticketAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketAssignment.
     * @param {TicketAssignmentUpsertArgs} args - Arguments to update or create a TicketAssignment.
     * @example
     * // Update or create a TicketAssignment
     * const ticketAssignment = await prisma.ticketAssignment.upsert({
     *   create: {
     *     // ... data to create a TicketAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAssignmentUpsertArgs>(args: SelectSubset<T, TicketAssignmentUpsertArgs<ExtArgs>>): Prisma__TicketAssignmentClient<$Result.GetResult<Prisma.$TicketAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentCountArgs} args - Arguments to filter TicketAssignments to count.
     * @example
     * // Count the number of TicketAssignments
     * const count = await prisma.ticketAssignment.count({
     *   where: {
     *     // ... the filter for the TicketAssignments we want to count
     *   }
     * })
    **/
    count<T extends TicketAssignmentCountArgs>(
      args?: Subset<T, TicketAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAssignmentAggregateArgs>(args: Subset<T, TicketAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAssignmentAggregateType<T>>

    /**
     * Group by TicketAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAssignment model
   */
  readonly fields: TicketAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assigned_by_user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAssignment model
   */
  interface TicketAssignmentFieldRefs {
    readonly id: FieldRef<"TicketAssignment", 'Int'>
    readonly ticket_id: FieldRef<"TicketAssignment", 'Int'>
    readonly agent_id: FieldRef<"TicketAssignment", 'Int'>
    readonly assigned_by: FieldRef<"TicketAssignment", 'Int'>
    readonly assigned_at: FieldRef<"TicketAssignment", 'DateTime'>
    readonly unassigned_at: FieldRef<"TicketAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketAssignment findUnique
   */
  export type TicketAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAssignment to fetch.
     */
    where: TicketAssignmentWhereUniqueInput
  }

  /**
   * TicketAssignment findUniqueOrThrow
   */
  export type TicketAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAssignment to fetch.
     */
    where: TicketAssignmentWhereUniqueInput
  }

  /**
   * TicketAssignment findFirst
   */
  export type TicketAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAssignment to fetch.
     */
    where?: TicketAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAssignments to fetch.
     */
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAssignments.
     */
    cursor?: TicketAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAssignments.
     */
    distinct?: TicketAssignmentScalarFieldEnum | TicketAssignmentScalarFieldEnum[]
  }

  /**
   * TicketAssignment findFirstOrThrow
   */
  export type TicketAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAssignment to fetch.
     */
    where?: TicketAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAssignments to fetch.
     */
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAssignments.
     */
    cursor?: TicketAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAssignments.
     */
    distinct?: TicketAssignmentScalarFieldEnum | TicketAssignmentScalarFieldEnum[]
  }

  /**
   * TicketAssignment findMany
   */
  export type TicketAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAssignments to fetch.
     */
    where?: TicketAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAssignments to fetch.
     */
    orderBy?: TicketAssignmentOrderByWithRelationInput | TicketAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAssignments.
     */
    cursor?: TicketAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAssignments.
     */
    skip?: number
    distinct?: TicketAssignmentScalarFieldEnum | TicketAssignmentScalarFieldEnum[]
  }

  /**
   * TicketAssignment create
   */
  export type TicketAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAssignment.
     */
    data: XOR<TicketAssignmentCreateInput, TicketAssignmentUncheckedCreateInput>
  }

  /**
   * TicketAssignment createMany
   */
  export type TicketAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAssignments.
     */
    data: TicketAssignmentCreateManyInput | TicketAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketAssignment createManyAndReturn
   */
  export type TicketAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketAssignments.
     */
    data: TicketAssignmentCreateManyInput | TicketAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAssignment update
   */
  export type TicketAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAssignment.
     */
    data: XOR<TicketAssignmentUpdateInput, TicketAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAssignment to update.
     */
    where: TicketAssignmentWhereUniqueInput
  }

  /**
   * TicketAssignment updateMany
   */
  export type TicketAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAssignments.
     */
    data: XOR<TicketAssignmentUpdateManyMutationInput, TicketAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAssignments to update
     */
    where?: TicketAssignmentWhereInput
    /**
     * Limit how many TicketAssignments to update.
     */
    limit?: number
  }

  /**
   * TicketAssignment updateManyAndReturn
   */
  export type TicketAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update TicketAssignments.
     */
    data: XOR<TicketAssignmentUpdateManyMutationInput, TicketAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAssignments to update
     */
    where?: TicketAssignmentWhereInput
    /**
     * Limit how many TicketAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAssignment upsert
   */
  export type TicketAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAssignment to update in case it exists.
     */
    where: TicketAssignmentWhereUniqueInput
    /**
     * In case the TicketAssignment found by the `where` argument doesn't exist, create a new TicketAssignment with this data.
     */
    create: XOR<TicketAssignmentCreateInput, TicketAssignmentUncheckedCreateInput>
    /**
     * In case the TicketAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAssignmentUpdateInput, TicketAssignmentUncheckedUpdateInput>
  }

  /**
   * TicketAssignment delete
   */
  export type TicketAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAssignment to delete.
     */
    where: TicketAssignmentWhereUniqueInput
  }

  /**
   * TicketAssignment deleteMany
   */
  export type TicketAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAssignments to delete
     */
    where?: TicketAssignmentWhereInput
    /**
     * Limit how many TicketAssignments to delete.
     */
    limit?: number
  }

  /**
   * TicketAssignment without action
   */
  export type TicketAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAssignment
     */
    select?: TicketAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAssignment
     */
    omit?: TicketAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: number | null
    setting_key: string | null
    setting_value: string | null
    description: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: number | null
    setting_key: string | null
    setting_value: string | null
    description: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    setting_key: number
    setting_value: number
    description: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type SystemSettingsAvgAggregateInputType = {
    id?: true
  }

  export type SystemSettingsSumAggregateInputType = {
    id?: true
  }

  export type SystemSettingsMinAggregateInputType = {
    id?: true
    setting_key?: true
    setting_value?: true
    description?: true
    created_at?: true
    modified_at?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    setting_key?: true
    setting_value?: true
    description?: true
    created_at?: true
    modified_at?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    setting_key?: true
    setting_value?: true
    description?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _avg?: SystemSettingsAvgAggregateInputType
    _sum?: SystemSettingsSumAggregateInputType
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: number
    setting_key: string
    setting_value: string
    description: string | null
    created_at: Date
    modified_at: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setting_key?: boolean
    setting_value?: boolean
    description?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setting_key?: boolean
    setting_value?: boolean
    description?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setting_key?: boolean
    setting_value?: boolean
    description?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    setting_key?: boolean
    setting_value?: boolean
    description?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "setting_key" | "setting_value" | "description" | "created_at" | "modified_at", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      setting_key: string
      setting_value: string
      description: string | null
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'Int'>
    readonly setting_key: FieldRef<"SystemSettings", 'String'>
    readonly setting_value: FieldRef<"SystemSettings", 'String'>
    readonly description: FieldRef<"SystemSettings", 'String'>
    readonly created_at: FieldRef<"SystemSettings", 'DateTime'>
    readonly modified_at: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model ResponseTemplate
   */

  export type AggregateResponseTemplate = {
    _count: ResponseTemplateCountAggregateOutputType | null
    _avg: ResponseTemplateAvgAggregateOutputType | null
    _sum: ResponseTemplateSumAggregateOutputType | null
    _min: ResponseTemplateMinAggregateOutputType | null
    _max: ResponseTemplateMaxAggregateOutputType | null
  }

  export type ResponseTemplateAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type ResponseTemplateSumAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type ResponseTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    subject: string | null
    content: string | null
    category_id: number | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type ResponseTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    subject: string | null
    content: string | null
    category_id: number | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type ResponseTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    content: number
    category_id: number
    is_active: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type ResponseTemplateAvgAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type ResponseTemplateSumAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type ResponseTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    category_id?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type ResponseTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    category_id?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type ResponseTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    content?: true
    category_id?: true
    is_active?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type ResponseTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponseTemplate to aggregate.
     */
    where?: ResponseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTemplates to fetch.
     */
    orderBy?: ResponseTemplateOrderByWithRelationInput | ResponseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponseTemplates
    **/
    _count?: true | ResponseTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResponseTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResponseTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponseTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponseTemplateMaxAggregateInputType
  }

  export type GetResponseTemplateAggregateType<T extends ResponseTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateResponseTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponseTemplate[P]>
      : GetScalarType<T[P], AggregateResponseTemplate[P]>
  }




  export type ResponseTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseTemplateWhereInput
    orderBy?: ResponseTemplateOrderByWithAggregationInput | ResponseTemplateOrderByWithAggregationInput[]
    by: ResponseTemplateScalarFieldEnum[] | ResponseTemplateScalarFieldEnum
    having?: ResponseTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponseTemplateCountAggregateInputType | true
    _avg?: ResponseTemplateAvgAggregateInputType
    _sum?: ResponseTemplateSumAggregateInputType
    _min?: ResponseTemplateMinAggregateInputType
    _max?: ResponseTemplateMaxAggregateInputType
  }

  export type ResponseTemplateGroupByOutputType = {
    id: number
    name: string
    subject: string
    content: string
    category_id: number | null
    is_active: boolean
    created_at: Date
    modified_at: Date
    _count: ResponseTemplateCountAggregateOutputType | null
    _avg: ResponseTemplateAvgAggregateOutputType | null
    _sum: ResponseTemplateSumAggregateOutputType | null
    _min: ResponseTemplateMinAggregateOutputType | null
    _max: ResponseTemplateMaxAggregateOutputType | null
  }

  type GetResponseTemplateGroupByPayload<T extends ResponseTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponseTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponseTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponseTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ResponseTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ResponseTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    category?: boolean | ResponseTemplate$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["responseTemplate"]>

  export type ResponseTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    category?: boolean | ResponseTemplate$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["responseTemplate"]>

  export type ResponseTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
    category?: boolean | ResponseTemplate$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["responseTemplate"]>

  export type ResponseTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    category_id?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type ResponseTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "content" | "category_id" | "is_active" | "created_at" | "modified_at", ExtArgs["result"]["responseTemplate"]>
  export type ResponseTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResponseTemplate$categoryArgs<ExtArgs>
  }
  export type ResponseTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResponseTemplate$categoryArgs<ExtArgs>
  }
  export type ResponseTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResponseTemplate$categoryArgs<ExtArgs>
  }

  export type $ResponseTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponseTemplate"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      subject: string
      content: string
      category_id: number | null
      is_active: boolean
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["responseTemplate"]>
    composites: {}
  }

  type ResponseTemplateGetPayload<S extends boolean | null | undefined | ResponseTemplateDefaultArgs> = $Result.GetResult<Prisma.$ResponseTemplatePayload, S>

  type ResponseTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResponseTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResponseTemplateCountAggregateInputType | true
    }

  export interface ResponseTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponseTemplate'], meta: { name: 'ResponseTemplate' } }
    /**
     * Find zero or one ResponseTemplate that matches the filter.
     * @param {ResponseTemplateFindUniqueArgs} args - Arguments to find a ResponseTemplate
     * @example
     * // Get one ResponseTemplate
     * const responseTemplate = await prisma.responseTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponseTemplateFindUniqueArgs>(args: SelectSubset<T, ResponseTemplateFindUniqueArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResponseTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResponseTemplateFindUniqueOrThrowArgs} args - Arguments to find a ResponseTemplate
     * @example
     * // Get one ResponseTemplate
     * const responseTemplate = await prisma.responseTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponseTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponseTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponseTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateFindFirstArgs} args - Arguments to find a ResponseTemplate
     * @example
     * // Get one ResponseTemplate
     * const responseTemplate = await prisma.responseTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponseTemplateFindFirstArgs>(args?: SelectSubset<T, ResponseTemplateFindFirstArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponseTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateFindFirstOrThrowArgs} args - Arguments to find a ResponseTemplate
     * @example
     * // Get one ResponseTemplate
     * const responseTemplate = await prisma.responseTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponseTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponseTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResponseTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponseTemplates
     * const responseTemplates = await prisma.responseTemplate.findMany()
     * 
     * // Get first 10 ResponseTemplates
     * const responseTemplates = await prisma.responseTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responseTemplateWithIdOnly = await prisma.responseTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResponseTemplateFindManyArgs>(args?: SelectSubset<T, ResponseTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResponseTemplate.
     * @param {ResponseTemplateCreateArgs} args - Arguments to create a ResponseTemplate.
     * @example
     * // Create one ResponseTemplate
     * const ResponseTemplate = await prisma.responseTemplate.create({
     *   data: {
     *     // ... data to create a ResponseTemplate
     *   }
     * })
     * 
     */
    create<T extends ResponseTemplateCreateArgs>(args: SelectSubset<T, ResponseTemplateCreateArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResponseTemplates.
     * @param {ResponseTemplateCreateManyArgs} args - Arguments to create many ResponseTemplates.
     * @example
     * // Create many ResponseTemplates
     * const responseTemplate = await prisma.responseTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponseTemplateCreateManyArgs>(args?: SelectSubset<T, ResponseTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResponseTemplates and returns the data saved in the database.
     * @param {ResponseTemplateCreateManyAndReturnArgs} args - Arguments to create many ResponseTemplates.
     * @example
     * // Create many ResponseTemplates
     * const responseTemplate = await prisma.responseTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResponseTemplates and only return the `id`
     * const responseTemplateWithIdOnly = await prisma.responseTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponseTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponseTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResponseTemplate.
     * @param {ResponseTemplateDeleteArgs} args - Arguments to delete one ResponseTemplate.
     * @example
     * // Delete one ResponseTemplate
     * const ResponseTemplate = await prisma.responseTemplate.delete({
     *   where: {
     *     // ... filter to delete one ResponseTemplate
     *   }
     * })
     * 
     */
    delete<T extends ResponseTemplateDeleteArgs>(args: SelectSubset<T, ResponseTemplateDeleteArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResponseTemplate.
     * @param {ResponseTemplateUpdateArgs} args - Arguments to update one ResponseTemplate.
     * @example
     * // Update one ResponseTemplate
     * const responseTemplate = await prisma.responseTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponseTemplateUpdateArgs>(args: SelectSubset<T, ResponseTemplateUpdateArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResponseTemplates.
     * @param {ResponseTemplateDeleteManyArgs} args - Arguments to filter ResponseTemplates to delete.
     * @example
     * // Delete a few ResponseTemplates
     * const { count } = await prisma.responseTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponseTemplateDeleteManyArgs>(args?: SelectSubset<T, ResponseTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponseTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponseTemplates
     * const responseTemplate = await prisma.responseTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponseTemplateUpdateManyArgs>(args: SelectSubset<T, ResponseTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponseTemplates and returns the data updated in the database.
     * @param {ResponseTemplateUpdateManyAndReturnArgs} args - Arguments to update many ResponseTemplates.
     * @example
     * // Update many ResponseTemplates
     * const responseTemplate = await prisma.responseTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResponseTemplates and only return the `id`
     * const responseTemplateWithIdOnly = await prisma.responseTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResponseTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ResponseTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResponseTemplate.
     * @param {ResponseTemplateUpsertArgs} args - Arguments to update or create a ResponseTemplate.
     * @example
     * // Update or create a ResponseTemplate
     * const responseTemplate = await prisma.responseTemplate.upsert({
     *   create: {
     *     // ... data to create a ResponseTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponseTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ResponseTemplateUpsertArgs>(args: SelectSubset<T, ResponseTemplateUpsertArgs<ExtArgs>>): Prisma__ResponseTemplateClient<$Result.GetResult<Prisma.$ResponseTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResponseTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateCountArgs} args - Arguments to filter ResponseTemplates to count.
     * @example
     * // Count the number of ResponseTemplates
     * const count = await prisma.responseTemplate.count({
     *   where: {
     *     // ... the filter for the ResponseTemplates we want to count
     *   }
     * })
    **/
    count<T extends ResponseTemplateCountArgs>(
      args?: Subset<T, ResponseTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponseTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponseTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponseTemplateAggregateArgs>(args: Subset<T, ResponseTemplateAggregateArgs>): Prisma.PrismaPromise<GetResponseTemplateAggregateType<T>>

    /**
     * Group by ResponseTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponseTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponseTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ResponseTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponseTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponseTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponseTemplate model
   */
  readonly fields: ResponseTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponseTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponseTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ResponseTemplate$categoryArgs<ExtArgs> = {}>(args?: Subset<T, ResponseTemplate$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponseTemplate model
   */
  interface ResponseTemplateFieldRefs {
    readonly id: FieldRef<"ResponseTemplate", 'Int'>
    readonly name: FieldRef<"ResponseTemplate", 'String'>
    readonly subject: FieldRef<"ResponseTemplate", 'String'>
    readonly content: FieldRef<"ResponseTemplate", 'String'>
    readonly category_id: FieldRef<"ResponseTemplate", 'Int'>
    readonly is_active: FieldRef<"ResponseTemplate", 'Boolean'>
    readonly created_at: FieldRef<"ResponseTemplate", 'DateTime'>
    readonly modified_at: FieldRef<"ResponseTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResponseTemplate findUnique
   */
  export type ResponseTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTemplate to fetch.
     */
    where: ResponseTemplateWhereUniqueInput
  }

  /**
   * ResponseTemplate findUniqueOrThrow
   */
  export type ResponseTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTemplate to fetch.
     */
    where: ResponseTemplateWhereUniqueInput
  }

  /**
   * ResponseTemplate findFirst
   */
  export type ResponseTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTemplate to fetch.
     */
    where?: ResponseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTemplates to fetch.
     */
    orderBy?: ResponseTemplateOrderByWithRelationInput | ResponseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponseTemplates.
     */
    cursor?: ResponseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponseTemplates.
     */
    distinct?: ResponseTemplateScalarFieldEnum | ResponseTemplateScalarFieldEnum[]
  }

  /**
   * ResponseTemplate findFirstOrThrow
   */
  export type ResponseTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTemplate to fetch.
     */
    where?: ResponseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTemplates to fetch.
     */
    orderBy?: ResponseTemplateOrderByWithRelationInput | ResponseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponseTemplates.
     */
    cursor?: ResponseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponseTemplates.
     */
    distinct?: ResponseTemplateScalarFieldEnum | ResponseTemplateScalarFieldEnum[]
  }

  /**
   * ResponseTemplate findMany
   */
  export type ResponseTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ResponseTemplates to fetch.
     */
    where?: ResponseTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseTemplates to fetch.
     */
    orderBy?: ResponseTemplateOrderByWithRelationInput | ResponseTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponseTemplates.
     */
    cursor?: ResponseTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseTemplates.
     */
    skip?: number
    distinct?: ResponseTemplateScalarFieldEnum | ResponseTemplateScalarFieldEnum[]
  }

  /**
   * ResponseTemplate create
   */
  export type ResponseTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ResponseTemplate.
     */
    data: XOR<ResponseTemplateCreateInput, ResponseTemplateUncheckedCreateInput>
  }

  /**
   * ResponseTemplate createMany
   */
  export type ResponseTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponseTemplates.
     */
    data: ResponseTemplateCreateManyInput | ResponseTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponseTemplate createManyAndReturn
   */
  export type ResponseTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ResponseTemplates.
     */
    data: ResponseTemplateCreateManyInput | ResponseTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResponseTemplate update
   */
  export type ResponseTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ResponseTemplate.
     */
    data: XOR<ResponseTemplateUpdateInput, ResponseTemplateUncheckedUpdateInput>
    /**
     * Choose, which ResponseTemplate to update.
     */
    where: ResponseTemplateWhereUniqueInput
  }

  /**
   * ResponseTemplate updateMany
   */
  export type ResponseTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponseTemplates.
     */
    data: XOR<ResponseTemplateUpdateManyMutationInput, ResponseTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ResponseTemplates to update
     */
    where?: ResponseTemplateWhereInput
    /**
     * Limit how many ResponseTemplates to update.
     */
    limit?: number
  }

  /**
   * ResponseTemplate updateManyAndReturn
   */
  export type ResponseTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ResponseTemplates.
     */
    data: XOR<ResponseTemplateUpdateManyMutationInput, ResponseTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ResponseTemplates to update
     */
    where?: ResponseTemplateWhereInput
    /**
     * Limit how many ResponseTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResponseTemplate upsert
   */
  export type ResponseTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ResponseTemplate to update in case it exists.
     */
    where: ResponseTemplateWhereUniqueInput
    /**
     * In case the ResponseTemplate found by the `where` argument doesn't exist, create a new ResponseTemplate with this data.
     */
    create: XOR<ResponseTemplateCreateInput, ResponseTemplateUncheckedCreateInput>
    /**
     * In case the ResponseTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponseTemplateUpdateInput, ResponseTemplateUncheckedUpdateInput>
  }

  /**
   * ResponseTemplate delete
   */
  export type ResponseTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
    /**
     * Filter which ResponseTemplate to delete.
     */
    where: ResponseTemplateWhereUniqueInput
  }

  /**
   * ResponseTemplate deleteMany
   */
  export type ResponseTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponseTemplates to delete
     */
    where?: ResponseTemplateWhereInput
    /**
     * Limit how many ResponseTemplates to delete.
     */
    limit?: number
  }

  /**
   * ResponseTemplate.category
   */
  export type ResponseTemplate$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * ResponseTemplate without action
   */
  export type ResponseTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseTemplate
     */
    select?: ResponseTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponseTemplate
     */
    omit?: ResponseTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseTemplateInclude<ExtArgs> | null
  }


  /**
   * Model SLA
   */

  export type AggregateSLA = {
    _count: SLACountAggregateOutputType | null
    _avg: SLAAvgAggregateOutputType | null
    _sum: SLASumAggregateOutputType | null
    _min: SLAMinAggregateOutputType | null
    _max: SLAMaxAggregateOutputType | null
  }

  export type SLAAvgAggregateOutputType = {
    id: number | null
    response_time: number | null
    resolution_time: number | null
  }

  export type SLASumAggregateOutputType = {
    id: number | null
    response_time: number | null
    resolution_time: number | null
  }

  export type SLAMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    priority: $Enums.Priority | null
    response_time: number | null
    resolution_time: number | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type SLAMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    priority: $Enums.Priority | null
    response_time: number | null
    resolution_time: number | null
    is_active: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type SLACountAggregateOutputType = {
    id: number
    name: number
    description: number
    priority: number
    response_time: number
    resolution_time: number
    is_active: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type SLAAvgAggregateInputType = {
    id?: true
    response_time?: true
    resolution_time?: true
  }

  export type SLASumAggregateInputType = {
    id?: true
    response_time?: true
    resolution_time?: true
  }

  export type SLAMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    response_time?: true
    resolution_time?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type SLAMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    response_time?: true
    resolution_time?: true
    is_active?: true
    created_at?: true
    modified_at?: true
  }

  export type SLACountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priority?: true
    response_time?: true
    resolution_time?: true
    is_active?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type SLAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SLA to aggregate.
     */
    where?: SLAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SLAS to fetch.
     */
    orderBy?: SLAOrderByWithRelationInput | SLAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SLAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SLAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SLAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SLAS
    **/
    _count?: true | SLACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SLAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SLASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SLAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SLAMaxAggregateInputType
  }

  export type GetSLAAggregateType<T extends SLAAggregateArgs> = {
        [P in keyof T & keyof AggregateSLA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSLA[P]>
      : GetScalarType<T[P], AggregateSLA[P]>
  }




  export type SLAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SLAWhereInput
    orderBy?: SLAOrderByWithAggregationInput | SLAOrderByWithAggregationInput[]
    by: SLAScalarFieldEnum[] | SLAScalarFieldEnum
    having?: SLAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SLACountAggregateInputType | true
    _avg?: SLAAvgAggregateInputType
    _sum?: SLASumAggregateInputType
    _min?: SLAMinAggregateInputType
    _max?: SLAMaxAggregateInputType
  }

  export type SLAGroupByOutputType = {
    id: number
    name: string
    description: string | null
    priority: $Enums.Priority
    response_time: number
    resolution_time: number
    is_active: boolean
    created_at: Date
    modified_at: Date
    _count: SLACountAggregateOutputType | null
    _avg: SLAAvgAggregateOutputType | null
    _sum: SLASumAggregateOutputType | null
    _min: SLAMinAggregateOutputType | null
    _max: SLAMaxAggregateOutputType | null
  }

  type GetSLAGroupByPayload<T extends SLAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SLAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SLAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SLAGroupByOutputType[P]>
            : GetScalarType<T[P], SLAGroupByOutputType[P]>
        }
      >
    >


  export type SLASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    response_time?: boolean
    resolution_time?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["sLA"]>

  export type SLASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    response_time?: boolean
    resolution_time?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["sLA"]>

  export type SLASelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    response_time?: boolean
    resolution_time?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["sLA"]>

  export type SLASelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    response_time?: boolean
    resolution_time?: boolean
    is_active?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type SLAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "priority" | "response_time" | "resolution_time" | "is_active" | "created_at" | "modified_at", ExtArgs["result"]["sLA"]>

  export type $SLAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SLA"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      priority: $Enums.Priority
      response_time: number
      resolution_time: number
      is_active: boolean
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["sLA"]>
    composites: {}
  }

  type SLAGetPayload<S extends boolean | null | undefined | SLADefaultArgs> = $Result.GetResult<Prisma.$SLAPayload, S>

  type SLACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SLAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SLACountAggregateInputType | true
    }

  export interface SLADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SLA'], meta: { name: 'SLA' } }
    /**
     * Find zero or one SLA that matches the filter.
     * @param {SLAFindUniqueArgs} args - Arguments to find a SLA
     * @example
     * // Get one SLA
     * const sLA = await prisma.sLA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SLAFindUniqueArgs>(args: SelectSubset<T, SLAFindUniqueArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SLA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SLAFindUniqueOrThrowArgs} args - Arguments to find a SLA
     * @example
     * // Get one SLA
     * const sLA = await prisma.sLA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SLAFindUniqueOrThrowArgs>(args: SelectSubset<T, SLAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SLA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLAFindFirstArgs} args - Arguments to find a SLA
     * @example
     * // Get one SLA
     * const sLA = await prisma.sLA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SLAFindFirstArgs>(args?: SelectSubset<T, SLAFindFirstArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SLA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLAFindFirstOrThrowArgs} args - Arguments to find a SLA
     * @example
     * // Get one SLA
     * const sLA = await prisma.sLA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SLAFindFirstOrThrowArgs>(args?: SelectSubset<T, SLAFindFirstOrThrowArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SLAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SLAS
     * const sLAS = await prisma.sLA.findMany()
     * 
     * // Get first 10 SLAS
     * const sLAS = await prisma.sLA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sLAWithIdOnly = await prisma.sLA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SLAFindManyArgs>(args?: SelectSubset<T, SLAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SLA.
     * @param {SLACreateArgs} args - Arguments to create a SLA.
     * @example
     * // Create one SLA
     * const SLA = await prisma.sLA.create({
     *   data: {
     *     // ... data to create a SLA
     *   }
     * })
     * 
     */
    create<T extends SLACreateArgs>(args: SelectSubset<T, SLACreateArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SLAS.
     * @param {SLACreateManyArgs} args - Arguments to create many SLAS.
     * @example
     * // Create many SLAS
     * const sLA = await prisma.sLA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SLACreateManyArgs>(args?: SelectSubset<T, SLACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SLAS and returns the data saved in the database.
     * @param {SLACreateManyAndReturnArgs} args - Arguments to create many SLAS.
     * @example
     * // Create many SLAS
     * const sLA = await prisma.sLA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SLAS and only return the `id`
     * const sLAWithIdOnly = await prisma.sLA.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SLACreateManyAndReturnArgs>(args?: SelectSubset<T, SLACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SLA.
     * @param {SLADeleteArgs} args - Arguments to delete one SLA.
     * @example
     * // Delete one SLA
     * const SLA = await prisma.sLA.delete({
     *   where: {
     *     // ... filter to delete one SLA
     *   }
     * })
     * 
     */
    delete<T extends SLADeleteArgs>(args: SelectSubset<T, SLADeleteArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SLA.
     * @param {SLAUpdateArgs} args - Arguments to update one SLA.
     * @example
     * // Update one SLA
     * const sLA = await prisma.sLA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SLAUpdateArgs>(args: SelectSubset<T, SLAUpdateArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SLAS.
     * @param {SLADeleteManyArgs} args - Arguments to filter SLAS to delete.
     * @example
     * // Delete a few SLAS
     * const { count } = await prisma.sLA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SLADeleteManyArgs>(args?: SelectSubset<T, SLADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SLAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SLAS
     * const sLA = await prisma.sLA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SLAUpdateManyArgs>(args: SelectSubset<T, SLAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SLAS and returns the data updated in the database.
     * @param {SLAUpdateManyAndReturnArgs} args - Arguments to update many SLAS.
     * @example
     * // Update many SLAS
     * const sLA = await prisma.sLA.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SLAS and only return the `id`
     * const sLAWithIdOnly = await prisma.sLA.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SLAUpdateManyAndReturnArgs>(args: SelectSubset<T, SLAUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SLA.
     * @param {SLAUpsertArgs} args - Arguments to update or create a SLA.
     * @example
     * // Update or create a SLA
     * const sLA = await prisma.sLA.upsert({
     *   create: {
     *     // ... data to create a SLA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SLA we want to update
     *   }
     * })
     */
    upsert<T extends SLAUpsertArgs>(args: SelectSubset<T, SLAUpsertArgs<ExtArgs>>): Prisma__SLAClient<$Result.GetResult<Prisma.$SLAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SLAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLACountArgs} args - Arguments to filter SLAS to count.
     * @example
     * // Count the number of SLAS
     * const count = await prisma.sLA.count({
     *   where: {
     *     // ... the filter for the SLAS we want to count
     *   }
     * })
    **/
    count<T extends SLACountArgs>(
      args?: Subset<T, SLACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SLACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SLA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SLAAggregateArgs>(args: Subset<T, SLAAggregateArgs>): Prisma.PrismaPromise<GetSLAAggregateType<T>>

    /**
     * Group by SLA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SLAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SLAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SLAGroupByArgs['orderBy'] }
        : { orderBy?: SLAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SLAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSLAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SLA model
   */
  readonly fields: SLAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SLA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SLAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SLA model
   */
  interface SLAFieldRefs {
    readonly id: FieldRef<"SLA", 'Int'>
    readonly name: FieldRef<"SLA", 'String'>
    readonly description: FieldRef<"SLA", 'String'>
    readonly priority: FieldRef<"SLA", 'Priority'>
    readonly response_time: FieldRef<"SLA", 'Int'>
    readonly resolution_time: FieldRef<"SLA", 'Int'>
    readonly is_active: FieldRef<"SLA", 'Boolean'>
    readonly created_at: FieldRef<"SLA", 'DateTime'>
    readonly modified_at: FieldRef<"SLA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SLA findUnique
   */
  export type SLAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * Filter, which SLA to fetch.
     */
    where: SLAWhereUniqueInput
  }

  /**
   * SLA findUniqueOrThrow
   */
  export type SLAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * Filter, which SLA to fetch.
     */
    where: SLAWhereUniqueInput
  }

  /**
   * SLA findFirst
   */
  export type SLAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * Filter, which SLA to fetch.
     */
    where?: SLAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SLAS to fetch.
     */
    orderBy?: SLAOrderByWithRelationInput | SLAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SLAS.
     */
    cursor?: SLAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SLAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SLAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SLAS.
     */
    distinct?: SLAScalarFieldEnum | SLAScalarFieldEnum[]
  }

  /**
   * SLA findFirstOrThrow
   */
  export type SLAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * Filter, which SLA to fetch.
     */
    where?: SLAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SLAS to fetch.
     */
    orderBy?: SLAOrderByWithRelationInput | SLAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SLAS.
     */
    cursor?: SLAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SLAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SLAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SLAS.
     */
    distinct?: SLAScalarFieldEnum | SLAScalarFieldEnum[]
  }

  /**
   * SLA findMany
   */
  export type SLAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * Filter, which SLAS to fetch.
     */
    where?: SLAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SLAS to fetch.
     */
    orderBy?: SLAOrderByWithRelationInput | SLAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SLAS.
     */
    cursor?: SLAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SLAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SLAS.
     */
    skip?: number
    distinct?: SLAScalarFieldEnum | SLAScalarFieldEnum[]
  }

  /**
   * SLA create
   */
  export type SLACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * The data needed to create a SLA.
     */
    data: XOR<SLACreateInput, SLAUncheckedCreateInput>
  }

  /**
   * SLA createMany
   */
  export type SLACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SLAS.
     */
    data: SLACreateManyInput | SLACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SLA createManyAndReturn
   */
  export type SLACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * The data used to create many SLAS.
     */
    data: SLACreateManyInput | SLACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SLA update
   */
  export type SLAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * The data needed to update a SLA.
     */
    data: XOR<SLAUpdateInput, SLAUncheckedUpdateInput>
    /**
     * Choose, which SLA to update.
     */
    where: SLAWhereUniqueInput
  }

  /**
   * SLA updateMany
   */
  export type SLAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SLAS.
     */
    data: XOR<SLAUpdateManyMutationInput, SLAUncheckedUpdateManyInput>
    /**
     * Filter which SLAS to update
     */
    where?: SLAWhereInput
    /**
     * Limit how many SLAS to update.
     */
    limit?: number
  }

  /**
   * SLA updateManyAndReturn
   */
  export type SLAUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * The data used to update SLAS.
     */
    data: XOR<SLAUpdateManyMutationInput, SLAUncheckedUpdateManyInput>
    /**
     * Filter which SLAS to update
     */
    where?: SLAWhereInput
    /**
     * Limit how many SLAS to update.
     */
    limit?: number
  }

  /**
   * SLA upsert
   */
  export type SLAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * The filter to search for the SLA to update in case it exists.
     */
    where: SLAWhereUniqueInput
    /**
     * In case the SLA found by the `where` argument doesn't exist, create a new SLA with this data.
     */
    create: XOR<SLACreateInput, SLAUncheckedCreateInput>
    /**
     * In case the SLA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SLAUpdateInput, SLAUncheckedUpdateInput>
  }

  /**
   * SLA delete
   */
  export type SLADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
    /**
     * Filter which SLA to delete.
     */
    where: SLAWhereUniqueInput
  }

  /**
   * SLA deleteMany
   */
  export type SLADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SLAS to delete
     */
    where?: SLAWhereInput
    /**
     * Limit how many SLAS to delete.
     */
    limit?: number
  }

  /**
   * SLA without action
   */
  export type SLADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SLA
     */
    select?: SLASelect<ExtArgs> | null
    /**
     * Omit specific fields from the SLA
     */
    omit?: SLAOmit<ExtArgs> | null
  }


  /**
   * Model TicketStatistics
   */

  export type AggregateTicketStatistics = {
    _count: TicketStatisticsCountAggregateOutputType | null
    _avg: TicketStatisticsAvgAggregateOutputType | null
    _sum: TicketStatisticsSumAggregateOutputType | null
    _min: TicketStatisticsMinAggregateOutputType | null
    _max: TicketStatisticsMaxAggregateOutputType | null
  }

  export type TicketStatisticsAvgAggregateOutputType = {
    id: number | null
    total_tickets: number | null
    open_tickets: number | null
    resolved_tickets: number | null
    closed_tickets: number | null
    avg_resolution_time: number | null
    avg_satisfaction: number | null
  }

  export type TicketStatisticsSumAggregateOutputType = {
    id: number | null
    total_tickets: number | null
    open_tickets: number | null
    resolved_tickets: number | null
    closed_tickets: number | null
    avg_resolution_time: number | null
    avg_satisfaction: number | null
  }

  export type TicketStatisticsMinAggregateOutputType = {
    id: number | null
    date: Date | null
    total_tickets: number | null
    open_tickets: number | null
    resolved_tickets: number | null
    closed_tickets: number | null
    avg_resolution_time: number | null
    avg_satisfaction: number | null
    created_at: Date | null
  }

  export type TicketStatisticsMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    total_tickets: number | null
    open_tickets: number | null
    resolved_tickets: number | null
    closed_tickets: number | null
    avg_resolution_time: number | null
    avg_satisfaction: number | null
    created_at: Date | null
  }

  export type TicketStatisticsCountAggregateOutputType = {
    id: number
    date: number
    total_tickets: number
    open_tickets: number
    resolved_tickets: number
    closed_tickets: number
    avg_resolution_time: number
    avg_satisfaction: number
    created_at: number
    _all: number
  }


  export type TicketStatisticsAvgAggregateInputType = {
    id?: true
    total_tickets?: true
    open_tickets?: true
    resolved_tickets?: true
    closed_tickets?: true
    avg_resolution_time?: true
    avg_satisfaction?: true
  }

  export type TicketStatisticsSumAggregateInputType = {
    id?: true
    total_tickets?: true
    open_tickets?: true
    resolved_tickets?: true
    closed_tickets?: true
    avg_resolution_time?: true
    avg_satisfaction?: true
  }

  export type TicketStatisticsMinAggregateInputType = {
    id?: true
    date?: true
    total_tickets?: true
    open_tickets?: true
    resolved_tickets?: true
    closed_tickets?: true
    avg_resolution_time?: true
    avg_satisfaction?: true
    created_at?: true
  }

  export type TicketStatisticsMaxAggregateInputType = {
    id?: true
    date?: true
    total_tickets?: true
    open_tickets?: true
    resolved_tickets?: true
    closed_tickets?: true
    avg_resolution_time?: true
    avg_satisfaction?: true
    created_at?: true
  }

  export type TicketStatisticsCountAggregateInputType = {
    id?: true
    date?: true
    total_tickets?: true
    open_tickets?: true
    resolved_tickets?: true
    closed_tickets?: true
    avg_resolution_time?: true
    avg_satisfaction?: true
    created_at?: true
    _all?: true
  }

  export type TicketStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketStatistics to aggregate.
     */
    where?: TicketStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketStatistics to fetch.
     */
    orderBy?: TicketStatisticsOrderByWithRelationInput | TicketStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketStatistics
    **/
    _count?: true | TicketStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketStatisticsMaxAggregateInputType
  }

  export type GetTicketStatisticsAggregateType<T extends TicketStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketStatistics[P]>
      : GetScalarType<T[P], AggregateTicketStatistics[P]>
  }




  export type TicketStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketStatisticsWhereInput
    orderBy?: TicketStatisticsOrderByWithAggregationInput | TicketStatisticsOrderByWithAggregationInput[]
    by: TicketStatisticsScalarFieldEnum[] | TicketStatisticsScalarFieldEnum
    having?: TicketStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketStatisticsCountAggregateInputType | true
    _avg?: TicketStatisticsAvgAggregateInputType
    _sum?: TicketStatisticsSumAggregateInputType
    _min?: TicketStatisticsMinAggregateInputType
    _max?: TicketStatisticsMaxAggregateInputType
  }

  export type TicketStatisticsGroupByOutputType = {
    id: number
    date: Date
    total_tickets: number
    open_tickets: number
    resolved_tickets: number
    closed_tickets: number
    avg_resolution_time: number
    avg_satisfaction: number
    created_at: Date
    _count: TicketStatisticsCountAggregateOutputType | null
    _avg: TicketStatisticsAvgAggregateOutputType | null
    _sum: TicketStatisticsSumAggregateOutputType | null
    _min: TicketStatisticsMinAggregateOutputType | null
    _max: TicketStatisticsMaxAggregateOutputType | null
  }

  type GetTicketStatisticsGroupByPayload<T extends TicketStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type TicketStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    total_tickets?: boolean
    open_tickets?: boolean
    resolved_tickets?: boolean
    closed_tickets?: boolean
    avg_resolution_time?: boolean
    avg_satisfaction?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ticketStatistics"]>

  export type TicketStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    total_tickets?: boolean
    open_tickets?: boolean
    resolved_tickets?: boolean
    closed_tickets?: boolean
    avg_resolution_time?: boolean
    avg_satisfaction?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ticketStatistics"]>

  export type TicketStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    total_tickets?: boolean
    open_tickets?: boolean
    resolved_tickets?: boolean
    closed_tickets?: boolean
    avg_resolution_time?: boolean
    avg_satisfaction?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ticketStatistics"]>

  export type TicketStatisticsSelectScalar = {
    id?: boolean
    date?: boolean
    total_tickets?: boolean
    open_tickets?: boolean
    resolved_tickets?: boolean
    closed_tickets?: boolean
    avg_resolution_time?: boolean
    avg_satisfaction?: boolean
    created_at?: boolean
  }

  export type TicketStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "total_tickets" | "open_tickets" | "resolved_tickets" | "closed_tickets" | "avg_resolution_time" | "avg_satisfaction" | "created_at", ExtArgs["result"]["ticketStatistics"]>

  export type $TicketStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketStatistics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      total_tickets: number
      open_tickets: number
      resolved_tickets: number
      closed_tickets: number
      avg_resolution_time: number
      avg_satisfaction: number
      created_at: Date
    }, ExtArgs["result"]["ticketStatistics"]>
    composites: {}
  }

  type TicketStatisticsGetPayload<S extends boolean | null | undefined | TicketStatisticsDefaultArgs> = $Result.GetResult<Prisma.$TicketStatisticsPayload, S>

  type TicketStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketStatisticsCountAggregateInputType | true
    }

  export interface TicketStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketStatistics'], meta: { name: 'TicketStatistics' } }
    /**
     * Find zero or one TicketStatistics that matches the filter.
     * @param {TicketStatisticsFindUniqueArgs} args - Arguments to find a TicketStatistics
     * @example
     * // Get one TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketStatisticsFindUniqueArgs>(args: SelectSubset<T, TicketStatisticsFindUniqueArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketStatisticsFindUniqueOrThrowArgs} args - Arguments to find a TicketStatistics
     * @example
     * // Get one TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsFindFirstArgs} args - Arguments to find a TicketStatistics
     * @example
     * // Get one TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketStatisticsFindFirstArgs>(args?: SelectSubset<T, TicketStatisticsFindFirstArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsFindFirstOrThrowArgs} args - Arguments to find a TicketStatistics
     * @example
     * // Get one TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.findMany()
     * 
     * // Get first 10 TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketStatisticsWithIdOnly = await prisma.ticketStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketStatisticsFindManyArgs>(args?: SelectSubset<T, TicketStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketStatistics.
     * @param {TicketStatisticsCreateArgs} args - Arguments to create a TicketStatistics.
     * @example
     * // Create one TicketStatistics
     * const TicketStatistics = await prisma.ticketStatistics.create({
     *   data: {
     *     // ... data to create a TicketStatistics
     *   }
     * })
     * 
     */
    create<T extends TicketStatisticsCreateArgs>(args: SelectSubset<T, TicketStatisticsCreateArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketStatistics.
     * @param {TicketStatisticsCreateManyArgs} args - Arguments to create many TicketStatistics.
     * @example
     * // Create many TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketStatisticsCreateManyArgs>(args?: SelectSubset<T, TicketStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketStatistics and returns the data saved in the database.
     * @param {TicketStatisticsCreateManyAndReturnArgs} args - Arguments to create many TicketStatistics.
     * @example
     * // Create many TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketStatistics and only return the `id`
     * const ticketStatisticsWithIdOnly = await prisma.ticketStatistics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketStatistics.
     * @param {TicketStatisticsDeleteArgs} args - Arguments to delete one TicketStatistics.
     * @example
     * // Delete one TicketStatistics
     * const TicketStatistics = await prisma.ticketStatistics.delete({
     *   where: {
     *     // ... filter to delete one TicketStatistics
     *   }
     * })
     * 
     */
    delete<T extends TicketStatisticsDeleteArgs>(args: SelectSubset<T, TicketStatisticsDeleteArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketStatistics.
     * @param {TicketStatisticsUpdateArgs} args - Arguments to update one TicketStatistics.
     * @example
     * // Update one TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketStatisticsUpdateArgs>(args: SelectSubset<T, TicketStatisticsUpdateArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketStatistics.
     * @param {TicketStatisticsDeleteManyArgs} args - Arguments to filter TicketStatistics to delete.
     * @example
     * // Delete a few TicketStatistics
     * const { count } = await prisma.ticketStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketStatisticsDeleteManyArgs>(args?: SelectSubset<T, TicketStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketStatisticsUpdateManyArgs>(args: SelectSubset<T, TicketStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketStatistics and returns the data updated in the database.
     * @param {TicketStatisticsUpdateManyAndReturnArgs} args - Arguments to update many TicketStatistics.
     * @example
     * // Update many TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketStatistics and only return the `id`
     * const ticketStatisticsWithIdOnly = await prisma.ticketStatistics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketStatistics.
     * @param {TicketStatisticsUpsertArgs} args - Arguments to update or create a TicketStatistics.
     * @example
     * // Update or create a TicketStatistics
     * const ticketStatistics = await prisma.ticketStatistics.upsert({
     *   create: {
     *     // ... data to create a TicketStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketStatistics we want to update
     *   }
     * })
     */
    upsert<T extends TicketStatisticsUpsertArgs>(args: SelectSubset<T, TicketStatisticsUpsertArgs<ExtArgs>>): Prisma__TicketStatisticsClient<$Result.GetResult<Prisma.$TicketStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsCountArgs} args - Arguments to filter TicketStatistics to count.
     * @example
     * // Count the number of TicketStatistics
     * const count = await prisma.ticketStatistics.count({
     *   where: {
     *     // ... the filter for the TicketStatistics we want to count
     *   }
     * })
    **/
    count<T extends TicketStatisticsCountArgs>(
      args?: Subset<T, TicketStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketStatisticsAggregateArgs>(args: Subset<T, TicketStatisticsAggregateArgs>): Prisma.PrismaPromise<GetTicketStatisticsAggregateType<T>>

    /**
     * Group by TicketStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: TicketStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketStatistics model
   */
  readonly fields: TicketStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketStatistics model
   */
  interface TicketStatisticsFieldRefs {
    readonly id: FieldRef<"TicketStatistics", 'Int'>
    readonly date: FieldRef<"TicketStatistics", 'DateTime'>
    readonly total_tickets: FieldRef<"TicketStatistics", 'Int'>
    readonly open_tickets: FieldRef<"TicketStatistics", 'Int'>
    readonly resolved_tickets: FieldRef<"TicketStatistics", 'Int'>
    readonly closed_tickets: FieldRef<"TicketStatistics", 'Int'>
    readonly avg_resolution_time: FieldRef<"TicketStatistics", 'Float'>
    readonly avg_satisfaction: FieldRef<"TicketStatistics", 'Float'>
    readonly created_at: FieldRef<"TicketStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketStatistics findUnique
   */
  export type TicketStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which TicketStatistics to fetch.
     */
    where: TicketStatisticsWhereUniqueInput
  }

  /**
   * TicketStatistics findUniqueOrThrow
   */
  export type TicketStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which TicketStatistics to fetch.
     */
    where: TicketStatisticsWhereUniqueInput
  }

  /**
   * TicketStatistics findFirst
   */
  export type TicketStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which TicketStatistics to fetch.
     */
    where?: TicketStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketStatistics to fetch.
     */
    orderBy?: TicketStatisticsOrderByWithRelationInput | TicketStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketStatistics.
     */
    cursor?: TicketStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketStatistics.
     */
    distinct?: TicketStatisticsScalarFieldEnum | TicketStatisticsScalarFieldEnum[]
  }

  /**
   * TicketStatistics findFirstOrThrow
   */
  export type TicketStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which TicketStatistics to fetch.
     */
    where?: TicketStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketStatistics to fetch.
     */
    orderBy?: TicketStatisticsOrderByWithRelationInput | TicketStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketStatistics.
     */
    cursor?: TicketStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketStatistics.
     */
    distinct?: TicketStatisticsScalarFieldEnum | TicketStatisticsScalarFieldEnum[]
  }

  /**
   * TicketStatistics findMany
   */
  export type TicketStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which TicketStatistics to fetch.
     */
    where?: TicketStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketStatistics to fetch.
     */
    orderBy?: TicketStatisticsOrderByWithRelationInput | TicketStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketStatistics.
     */
    cursor?: TicketStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketStatistics.
     */
    skip?: number
    distinct?: TicketStatisticsScalarFieldEnum | TicketStatisticsScalarFieldEnum[]
  }

  /**
   * TicketStatistics create
   */
  export type TicketStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * The data needed to create a TicketStatistics.
     */
    data: XOR<TicketStatisticsCreateInput, TicketStatisticsUncheckedCreateInput>
  }

  /**
   * TicketStatistics createMany
   */
  export type TicketStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketStatistics.
     */
    data: TicketStatisticsCreateManyInput | TicketStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketStatistics createManyAndReturn
   */
  export type TicketStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many TicketStatistics.
     */
    data: TicketStatisticsCreateManyInput | TicketStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketStatistics update
   */
  export type TicketStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * The data needed to update a TicketStatistics.
     */
    data: XOR<TicketStatisticsUpdateInput, TicketStatisticsUncheckedUpdateInput>
    /**
     * Choose, which TicketStatistics to update.
     */
    where: TicketStatisticsWhereUniqueInput
  }

  /**
   * TicketStatistics updateMany
   */
  export type TicketStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketStatistics.
     */
    data: XOR<TicketStatisticsUpdateManyMutationInput, TicketStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which TicketStatistics to update
     */
    where?: TicketStatisticsWhereInput
    /**
     * Limit how many TicketStatistics to update.
     */
    limit?: number
  }

  /**
   * TicketStatistics updateManyAndReturn
   */
  export type TicketStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update TicketStatistics.
     */
    data: XOR<TicketStatisticsUpdateManyMutationInput, TicketStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which TicketStatistics to update
     */
    where?: TicketStatisticsWhereInput
    /**
     * Limit how many TicketStatistics to update.
     */
    limit?: number
  }

  /**
   * TicketStatistics upsert
   */
  export type TicketStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * The filter to search for the TicketStatistics to update in case it exists.
     */
    where: TicketStatisticsWhereUniqueInput
    /**
     * In case the TicketStatistics found by the `where` argument doesn't exist, create a new TicketStatistics with this data.
     */
    create: XOR<TicketStatisticsCreateInput, TicketStatisticsUncheckedCreateInput>
    /**
     * In case the TicketStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketStatisticsUpdateInput, TicketStatisticsUncheckedUpdateInput>
  }

  /**
   * TicketStatistics delete
   */
  export type TicketStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
    /**
     * Filter which TicketStatistics to delete.
     */
    where: TicketStatisticsWhereUniqueInput
  }

  /**
   * TicketStatistics deleteMany
   */
  export type TicketStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketStatistics to delete
     */
    where?: TicketStatisticsWhereInput
    /**
     * Limit how many TicketStatistics to delete.
     */
    limit?: number
  }

  /**
   * TicketStatistics without action
   */
  export type TicketStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketStatistics
     */
    select?: TicketStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketStatistics
     */
    omit?: TicketStatisticsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    avatar: 'avatar',
    created_at: 'created_at',
    modified_at: 'modified_at',
    role: 'role',
    hashed_password: 'hashed_password',
    is_active: 'is_active'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    employee_id: 'employee_id',
    department: 'department',
    skills: 'skills',
    max_tickets: 'max_tickets',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    company: 'company',
    client_type: 'client_type',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    icon: 'icon',
    is_active: 'is_active',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubcategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category_id: 'category_id',
    is_active: 'is_active',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type SubcategoryScalarFieldEnum = (typeof SubcategoryScalarFieldEnum)[keyof typeof SubcategoryScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    ticket_number: 'ticket_number',
    title: 'title',
    description: 'description',
    priority: 'priority',
    status: 'status',
    category_id: 'category_id',
    subcategory_id: 'subcategory_id',
    client_id: 'client_id',
    created_by: 'created_by',
    assigned_to: 'assigned_to',
    due_date: 'due_date',
    resolution_time: 'resolution_time',
    satisfaction_rating: 'satisfaction_rating',
    created_at: 'created_at',
    modified_at: 'modified_at',
    closed_at: 'closed_at'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    user_id: 'user_id',
    content: 'content',
    is_internal: 'is_internal',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    original_name: 'original_name',
    file_path: 'file_path',
    file_size: 'file_size',
    mime_type: 'mime_type',
    ticket_id: 'ticket_id',
    comment_id: 'comment_id',
    created_at: 'created_at'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const TicketHistoryScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    field_name: 'field_name',
    old_value: 'old_value',
    new_value: 'new_value',
    changed_by: 'changed_by',
    created_at: 'created_at'
  };

  export type TicketHistoryScalarFieldEnum = (typeof TicketHistoryScalarFieldEnum)[keyof typeof TicketHistoryScalarFieldEnum]


  export const TicketAssignmentScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    agent_id: 'agent_id',
    assigned_by: 'assigned_by',
    assigned_at: 'assigned_at',
    unassigned_at: 'unassigned_at'
  };

  export type TicketAssignmentScalarFieldEnum = (typeof TicketAssignmentScalarFieldEnum)[keyof typeof TicketAssignmentScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    setting_key: 'setting_key',
    setting_value: 'setting_value',
    description: 'description',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const ResponseTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    content: 'content',
    category_id: 'category_id',
    is_active: 'is_active',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type ResponseTemplateScalarFieldEnum = (typeof ResponseTemplateScalarFieldEnum)[keyof typeof ResponseTemplateScalarFieldEnum]


  export const SLAScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priority: 'priority',
    response_time: 'response_time',
    resolution_time: 'resolution_time',
    is_active: 'is_active',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type SLAScalarFieldEnum = (typeof SLAScalarFieldEnum)[keyof typeof SLAScalarFieldEnum]


  export const TicketStatisticsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    total_tickets: 'total_tickets',
    open_tickets: 'open_tickets',
    resolved_tickets: 'resolved_tickets',
    closed_tickets: 'closed_tickets',
    avg_resolution_time: 'avg_resolution_time',
    avg_satisfaction: 'avg_satisfaction',
    created_at: 'created_at'
  };

  export type TicketStatisticsScalarFieldEnum = (typeof TicketStatisticsScalarFieldEnum)[keyof typeof TicketStatisticsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'ClientType[]'
   */
  export type ListEnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    modified_at?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    hashed_password?: StringFilter<"User"> | string
    is_active?: BoolFilter<"User"> | boolean
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    tickets_created?: TicketListRelationFilter
    tickets_assigned?: TicketListRelationFilter
    ticket_comments?: CommentListRelationFilter
    ticket_assignments?: TicketAssignmentListRelationFilter
    ticket_history?: TicketHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    role?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    agent?: AgentOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    tickets_created?: TicketOrderByRelationAggregateInput
    tickets_assigned?: TicketOrderByRelationAggregateInput
    ticket_comments?: CommentOrderByRelationAggregateInput
    ticket_assignments?: TicketAssignmentOrderByRelationAggregateInput
    ticket_history?: TicketHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    modified_at?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    hashed_password?: StringFilter<"User"> | string
    is_active?: BoolFilter<"User"> | boolean
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    tickets_created?: TicketListRelationFilter
    tickets_assigned?: TicketListRelationFilter
    ticket_comments?: CommentListRelationFilter
    ticket_assignments?: TicketAssignmentListRelationFilter
    ticket_history?: TicketHistoryListRelationFilter
  }, "id" | "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    role?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    hashed_password?: StringWithAggregatesFilter<"User"> | string
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: IntFilter<"Agent"> | number
    user_id?: IntFilter<"Agent"> | number
    employee_id?: StringFilter<"Agent"> | string
    department?: StringNullableFilter<"Agent"> | string | null
    skills?: StringNullableListFilter<"Agent">
    max_tickets?: IntFilter<"Agent"> | number
    created_at?: DateTimeFilter<"Agent"> | Date | string
    modified_at?: DateTimeFilter<"Agent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket_assignments?: TicketAssignmentListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    employee_id?: SortOrder
    department?: SortOrderInput | SortOrder
    skills?: SortOrder
    max_tickets?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user?: UserOrderByWithRelationInput
    ticket_assignments?: TicketAssignmentOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    employee_id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    department?: StringNullableFilter<"Agent"> | string | null
    skills?: StringNullableListFilter<"Agent">
    max_tickets?: IntFilter<"Agent"> | number
    created_at?: DateTimeFilter<"Agent"> | Date | string
    modified_at?: DateTimeFilter<"Agent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket_assignments?: TicketAssignmentListRelationFilter
  }, "id" | "id" | "user_id" | "employee_id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    employee_id?: SortOrder
    department?: SortOrderInput | SortOrder
    skills?: SortOrder
    max_tickets?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agent"> | number
    user_id?: IntWithAggregatesFilter<"Agent"> | number
    employee_id?: StringWithAggregatesFilter<"Agent"> | string
    department?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    skills?: StringNullableListFilter<"Agent">
    max_tickets?: IntWithAggregatesFilter<"Agent"> | number
    created_at?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    user_id?: IntFilter<"Client"> | number
    company?: StringNullableFilter<"Client"> | string | null
    client_type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    created_at?: DateTimeFilter<"Client"> | Date | string
    modified_at?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company?: SortOrderInput | SortOrder
    client_type?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user?: UserOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    company?: StringNullableFilter<"Client"> | string | null
    client_type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    created_at?: DateTimeFilter<"Client"> | Date | string
    modified_at?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tickets?: TicketListRelationFilter
  }, "id" | "id" | "user_id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company?: SortOrderInput | SortOrder
    client_type?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    user_id?: IntWithAggregatesFilter<"Client"> | number
    company?: StringNullableWithAggregatesFilter<"Client"> | string | null
    client_type?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    created_at?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    is_active?: BoolFilter<"Category"> | boolean
    created_at?: DateTimeFilter<"Category"> | Date | string
    modified_at?: DateTimeFilter<"Category"> | Date | string
    tickets?: TicketListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    response_templates?: ResponseTemplateListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    tickets?: TicketOrderByRelationAggregateInput
    subcategories?: SubcategoryOrderByRelationAggregateInput
    response_templates?: ResponseTemplateOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    is_active?: BoolFilter<"Category"> | boolean
    created_at?: DateTimeFilter<"Category"> | Date | string
    modified_at?: DateTimeFilter<"Category"> | Date | string
    tickets?: TicketListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    response_templates?: ResponseTemplateListRelationFilter
  }, "id" | "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    is_active?: BoolWithAggregatesFilter<"Category"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type SubcategoryWhereInput = {
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    id?: IntFilter<"Subcategory"> | number
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    category_id?: IntFilter<"Subcategory"> | number
    is_active?: BoolFilter<"Subcategory"> | boolean
    created_at?: DateTimeFilter<"Subcategory"> | Date | string
    modified_at?: DateTimeFilter<"Subcategory"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type SubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    category?: CategoryOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type SubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_category_id?: SubcategoryNameCategory_idCompoundUniqueInput
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    category_id?: IntFilter<"Subcategory"> | number
    is_active?: BoolFilter<"Subcategory"> | boolean
    created_at?: DateTimeFilter<"Subcategory"> | Date | string
    modified_at?: DateTimeFilter<"Subcategory"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    tickets?: TicketListRelationFilter
  }, "id" | "id" | "name_category_id">

  export type SubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: SubcategoryCountOrderByAggregateInput
    _avg?: SubcategoryAvgOrderByAggregateInput
    _max?: SubcategoryMaxOrderByAggregateInput
    _min?: SubcategoryMinOrderByAggregateInput
    _sum?: SubcategorySumOrderByAggregateInput
  }

  export type SubcategoryScalarWhereWithAggregatesInput = {
    AND?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    OR?: SubcategoryScalarWhereWithAggregatesInput[]
    NOT?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subcategory"> | number
    name?: StringWithAggregatesFilter<"Subcategory"> | string
    description?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    category_id?: IntWithAggregatesFilter<"Subcategory"> | number
    is_active?: BoolWithAggregatesFilter<"Subcategory"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Subcategory"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"Subcategory"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: IntFilter<"Ticket"> | number
    ticket_number?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    priority?: EnumPriorityFilter<"Ticket"> | $Enums.Priority
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    category_id?: IntFilter<"Ticket"> | number
    subcategory_id?: IntNullableFilter<"Ticket"> | number | null
    client_id?: IntFilter<"Ticket"> | number
    created_by?: IntFilter<"Ticket"> | number
    assigned_to?: IntNullableFilter<"Ticket"> | number | null
    due_date?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    resolution_time?: IntNullableFilter<"Ticket"> | number | null
    satisfaction_rating?: IntNullableFilter<"Ticket"> | number | null
    created_at?: DateTimeFilter<"Ticket"> | Date | string
    modified_at?: DateTimeFilter<"Ticket"> | Date | string
    closed_at?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subcategory?: XOR<SubcategoryNullableScalarRelationFilter, SubcategoryWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    ticket_history?: TicketHistoryListRelationFilter
    ticket_assignments?: TicketAssignmentListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    ticket_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    resolution_time?: SortOrderInput | SortOrder
    satisfaction_rating?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    closed_at?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    subcategory?: SubcategoryOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    ticket_history?: TicketHistoryOrderByRelationAggregateInput
    ticket_assignments?: TicketAssignmentOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ticket_number?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    priority?: EnumPriorityFilter<"Ticket"> | $Enums.Priority
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    category_id?: IntFilter<"Ticket"> | number
    subcategory_id?: IntNullableFilter<"Ticket"> | number | null
    client_id?: IntFilter<"Ticket"> | number
    created_by?: IntFilter<"Ticket"> | number
    assigned_to?: IntNullableFilter<"Ticket"> | number | null
    due_date?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    resolution_time?: IntNullableFilter<"Ticket"> | number | null
    satisfaction_rating?: IntNullableFilter<"Ticket"> | number | null
    created_at?: DateTimeFilter<"Ticket"> | Date | string
    modified_at?: DateTimeFilter<"Ticket"> | Date | string
    closed_at?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subcategory?: XOR<SubcategoryNullableScalarRelationFilter, SubcategoryWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    ticket_history?: TicketHistoryListRelationFilter
    ticket_assignments?: TicketAssignmentListRelationFilter
  }, "id" | "id" | "ticket_number">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    resolution_time?: SortOrderInput | SortOrder
    satisfaction_rating?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    closed_at?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ticket"> | number
    ticket_number?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    priority?: EnumPriorityWithAggregatesFilter<"Ticket"> | $Enums.Priority
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    category_id?: IntWithAggregatesFilter<"Ticket"> | number
    subcategory_id?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    client_id?: IntWithAggregatesFilter<"Ticket"> | number
    created_by?: IntWithAggregatesFilter<"Ticket"> | number
    assigned_to?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    due_date?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    resolution_time?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    satisfaction_rating?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    closed_at?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    ticket_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    is_internal?: BoolFilter<"Comment"> | boolean
    created_at?: DateTimeFilter<"Comment"> | Date | string
    modified_at?: DateTimeFilter<"Comment"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    ticket_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    is_internal?: BoolFilter<"Comment"> | boolean
    created_at?: DateTimeFilter<"Comment"> | Date | string
    modified_at?: DateTimeFilter<"Comment"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
  }, "id" | "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    ticket_id?: IntWithAggregatesFilter<"Comment"> | number
    user_id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    is_internal?: BoolWithAggregatesFilter<"Comment"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: IntFilter<"Attachment"> | number
    filename?: StringFilter<"Attachment"> | string
    original_name?: StringFilter<"Attachment"> | string
    file_path?: StringFilter<"Attachment"> | string
    file_size?: IntFilter<"Attachment"> | number
    mime_type?: StringFilter<"Attachment"> | string
    ticket_id?: IntNullableFilter<"Attachment"> | number | null
    comment_id?: IntNullableFilter<"Attachment"> | number | null
    created_at?: DateTimeFilter<"Attachment"> | Date | string
    ticket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    original_name?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    ticket_id?: SortOrderInput | SortOrder
    comment_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    filename?: StringFilter<"Attachment"> | string
    original_name?: StringFilter<"Attachment"> | string
    file_path?: StringFilter<"Attachment"> | string
    file_size?: IntFilter<"Attachment"> | number
    mime_type?: StringFilter<"Attachment"> | string
    ticket_id?: IntNullableFilter<"Attachment"> | number | null
    comment_id?: IntNullableFilter<"Attachment"> | number | null
    created_at?: DateTimeFilter<"Attachment"> | Date | string
    ticket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }, "id" | "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    original_name?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    ticket_id?: SortOrderInput | SortOrder
    comment_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attachment"> | number
    filename?: StringWithAggregatesFilter<"Attachment"> | string
    original_name?: StringWithAggregatesFilter<"Attachment"> | string
    file_path?: StringWithAggregatesFilter<"Attachment"> | string
    file_size?: IntWithAggregatesFilter<"Attachment"> | number
    mime_type?: StringWithAggregatesFilter<"Attachment"> | string
    ticket_id?: IntNullableWithAggregatesFilter<"Attachment"> | number | null
    comment_id?: IntNullableWithAggregatesFilter<"Attachment"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type TicketHistoryWhereInput = {
    AND?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    OR?: TicketHistoryWhereInput[]
    NOT?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    id?: IntFilter<"TicketHistory"> | number
    ticket_id?: IntFilter<"TicketHistory"> | number
    field_name?: StringFilter<"TicketHistory"> | string
    old_value?: StringNullableFilter<"TicketHistory"> | string | null
    new_value?: StringNullableFilter<"TicketHistory"> | string | null
    changed_by?: IntFilter<"TicketHistory"> | number
    created_at?: DateTimeFilter<"TicketHistory"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketHistoryOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    field_name?: SortOrder
    old_value?: SortOrderInput | SortOrder
    new_value?: SortOrderInput | SortOrder
    changed_by?: SortOrder
    created_at?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    OR?: TicketHistoryWhereInput[]
    NOT?: TicketHistoryWhereInput | TicketHistoryWhereInput[]
    ticket_id?: IntFilter<"TicketHistory"> | number
    field_name?: StringFilter<"TicketHistory"> | string
    old_value?: StringNullableFilter<"TicketHistory"> | string | null
    new_value?: StringNullableFilter<"TicketHistory"> | string | null
    changed_by?: IntFilter<"TicketHistory"> | number
    created_at?: DateTimeFilter<"TicketHistory"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type TicketHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    field_name?: SortOrder
    old_value?: SortOrderInput | SortOrder
    new_value?: SortOrderInput | SortOrder
    changed_by?: SortOrder
    created_at?: SortOrder
    _count?: TicketHistoryCountOrderByAggregateInput
    _avg?: TicketHistoryAvgOrderByAggregateInput
    _max?: TicketHistoryMaxOrderByAggregateInput
    _min?: TicketHistoryMinOrderByAggregateInput
    _sum?: TicketHistorySumOrderByAggregateInput
  }

  export type TicketHistoryScalarWhereWithAggregatesInput = {
    AND?: TicketHistoryScalarWhereWithAggregatesInput | TicketHistoryScalarWhereWithAggregatesInput[]
    OR?: TicketHistoryScalarWhereWithAggregatesInput[]
    NOT?: TicketHistoryScalarWhereWithAggregatesInput | TicketHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketHistory"> | number
    ticket_id?: IntWithAggregatesFilter<"TicketHistory"> | number
    field_name?: StringWithAggregatesFilter<"TicketHistory"> | string
    old_value?: StringNullableWithAggregatesFilter<"TicketHistory"> | string | null
    new_value?: StringNullableWithAggregatesFilter<"TicketHistory"> | string | null
    changed_by?: IntWithAggregatesFilter<"TicketHistory"> | number
    created_at?: DateTimeWithAggregatesFilter<"TicketHistory"> | Date | string
  }

  export type TicketAssignmentWhereInput = {
    AND?: TicketAssignmentWhereInput | TicketAssignmentWhereInput[]
    OR?: TicketAssignmentWhereInput[]
    NOT?: TicketAssignmentWhereInput | TicketAssignmentWhereInput[]
    id?: IntFilter<"TicketAssignment"> | number
    ticket_id?: IntFilter<"TicketAssignment"> | number
    agent_id?: IntFilter<"TicketAssignment"> | number
    assigned_by?: IntFilter<"TicketAssignment"> | number
    assigned_at?: DateTimeFilter<"TicketAssignment"> | Date | string
    unassigned_at?: DateTimeNullableFilter<"TicketAssignment"> | Date | string | null
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    assigned_by_user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
    assigned_at?: SortOrder
    unassigned_at?: SortOrderInput | SortOrder
    ticket?: TicketOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    assigned_by_user?: UserOrderByWithRelationInput
  }

  export type TicketAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketAssignmentWhereInput | TicketAssignmentWhereInput[]
    OR?: TicketAssignmentWhereInput[]
    NOT?: TicketAssignmentWhereInput | TicketAssignmentWhereInput[]
    ticket_id?: IntFilter<"TicketAssignment"> | number
    agent_id?: IntFilter<"TicketAssignment"> | number
    assigned_by?: IntFilter<"TicketAssignment"> | number
    assigned_at?: DateTimeFilter<"TicketAssignment"> | Date | string
    unassigned_at?: DateTimeNullableFilter<"TicketAssignment"> | Date | string | null
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    assigned_by_user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type TicketAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
    assigned_at?: SortOrder
    unassigned_at?: SortOrderInput | SortOrder
    _count?: TicketAssignmentCountOrderByAggregateInput
    _avg?: TicketAssignmentAvgOrderByAggregateInput
    _max?: TicketAssignmentMaxOrderByAggregateInput
    _min?: TicketAssignmentMinOrderByAggregateInput
    _sum?: TicketAssignmentSumOrderByAggregateInput
  }

  export type TicketAssignmentScalarWhereWithAggregatesInput = {
    AND?: TicketAssignmentScalarWhereWithAggregatesInput | TicketAssignmentScalarWhereWithAggregatesInput[]
    OR?: TicketAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAssignmentScalarWhereWithAggregatesInput | TicketAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketAssignment"> | number
    ticket_id?: IntWithAggregatesFilter<"TicketAssignment"> | number
    agent_id?: IntWithAggregatesFilter<"TicketAssignment"> | number
    assigned_by?: IntWithAggregatesFilter<"TicketAssignment"> | number
    assigned_at?: DateTimeWithAggregatesFilter<"TicketAssignment"> | Date | string
    unassigned_at?: DateTimeNullableWithAggregatesFilter<"TicketAssignment"> | Date | string | null
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: IntFilter<"SystemSettings"> | number
    setting_key?: StringFilter<"SystemSettings"> | string
    setting_value?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    created_at?: DateTimeFilter<"SystemSettings"> | Date | string
    modified_at?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    setting_key?: SortOrder
    setting_value?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    setting_key?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    setting_value?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    created_at?: DateTimeFilter<"SystemSettings"> | Date | string
    modified_at?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id" | "id" | "setting_key">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    setting_key?: SortOrder
    setting_value?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _avg?: SystemSettingsAvgOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
    _sum?: SystemSettingsSumOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSettings"> | number
    setting_key?: StringWithAggregatesFilter<"SystemSettings"> | string
    setting_value?: StringWithAggregatesFilter<"SystemSettings"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type ResponseTemplateWhereInput = {
    AND?: ResponseTemplateWhereInput | ResponseTemplateWhereInput[]
    OR?: ResponseTemplateWhereInput[]
    NOT?: ResponseTemplateWhereInput | ResponseTemplateWhereInput[]
    id?: IntFilter<"ResponseTemplate"> | number
    name?: StringFilter<"ResponseTemplate"> | string
    subject?: StringFilter<"ResponseTemplate"> | string
    content?: StringFilter<"ResponseTemplate"> | string
    category_id?: IntNullableFilter<"ResponseTemplate"> | number | null
    is_active?: BoolFilter<"ResponseTemplate"> | boolean
    created_at?: DateTimeFilter<"ResponseTemplate"> | Date | string
    modified_at?: DateTimeFilter<"ResponseTemplate"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }

  export type ResponseTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category_id?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    category?: CategoryOrderByWithRelationInput
  }

  export type ResponseTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ResponseTemplateWhereInput | ResponseTemplateWhereInput[]
    OR?: ResponseTemplateWhereInput[]
    NOT?: ResponseTemplateWhereInput | ResponseTemplateWhereInput[]
    subject?: StringFilter<"ResponseTemplate"> | string
    content?: StringFilter<"ResponseTemplate"> | string
    category_id?: IntNullableFilter<"ResponseTemplate"> | number | null
    is_active?: BoolFilter<"ResponseTemplate"> | boolean
    created_at?: DateTimeFilter<"ResponseTemplate"> | Date | string
    modified_at?: DateTimeFilter<"ResponseTemplate"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }, "id" | "id" | "name">

  export type ResponseTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category_id?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: ResponseTemplateCountOrderByAggregateInput
    _avg?: ResponseTemplateAvgOrderByAggregateInput
    _max?: ResponseTemplateMaxOrderByAggregateInput
    _min?: ResponseTemplateMinOrderByAggregateInput
    _sum?: ResponseTemplateSumOrderByAggregateInput
  }

  export type ResponseTemplateScalarWhereWithAggregatesInput = {
    AND?: ResponseTemplateScalarWhereWithAggregatesInput | ResponseTemplateScalarWhereWithAggregatesInput[]
    OR?: ResponseTemplateScalarWhereWithAggregatesInput[]
    NOT?: ResponseTemplateScalarWhereWithAggregatesInput | ResponseTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ResponseTemplate"> | number
    name?: StringWithAggregatesFilter<"ResponseTemplate"> | string
    subject?: StringWithAggregatesFilter<"ResponseTemplate"> | string
    content?: StringWithAggregatesFilter<"ResponseTemplate"> | string
    category_id?: IntNullableWithAggregatesFilter<"ResponseTemplate"> | number | null
    is_active?: BoolWithAggregatesFilter<"ResponseTemplate"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ResponseTemplate"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"ResponseTemplate"> | Date | string
  }

  export type SLAWhereInput = {
    AND?: SLAWhereInput | SLAWhereInput[]
    OR?: SLAWhereInput[]
    NOT?: SLAWhereInput | SLAWhereInput[]
    id?: IntFilter<"SLA"> | number
    name?: StringFilter<"SLA"> | string
    description?: StringNullableFilter<"SLA"> | string | null
    priority?: EnumPriorityFilter<"SLA"> | $Enums.Priority
    response_time?: IntFilter<"SLA"> | number
    resolution_time?: IntFilter<"SLA"> | number
    is_active?: BoolFilter<"SLA"> | boolean
    created_at?: DateTimeFilter<"SLA"> | Date | string
    modified_at?: DateTimeFilter<"SLA"> | Date | string
  }

  export type SLAOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SLAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SLAWhereInput | SLAWhereInput[]
    OR?: SLAWhereInput[]
    NOT?: SLAWhereInput | SLAWhereInput[]
    description?: StringNullableFilter<"SLA"> | string | null
    priority?: EnumPriorityFilter<"SLA"> | $Enums.Priority
    response_time?: IntFilter<"SLA"> | number
    resolution_time?: IntFilter<"SLA"> | number
    is_active?: BoolFilter<"SLA"> | boolean
    created_at?: DateTimeFilter<"SLA"> | Date | string
    modified_at?: DateTimeFilter<"SLA"> | Date | string
  }, "id" | "id" | "name">

  export type SLAOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: SLACountOrderByAggregateInput
    _avg?: SLAAvgOrderByAggregateInput
    _max?: SLAMaxOrderByAggregateInput
    _min?: SLAMinOrderByAggregateInput
    _sum?: SLASumOrderByAggregateInput
  }

  export type SLAScalarWhereWithAggregatesInput = {
    AND?: SLAScalarWhereWithAggregatesInput | SLAScalarWhereWithAggregatesInput[]
    OR?: SLAScalarWhereWithAggregatesInput[]
    NOT?: SLAScalarWhereWithAggregatesInput | SLAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SLA"> | number
    name?: StringWithAggregatesFilter<"SLA"> | string
    description?: StringNullableWithAggregatesFilter<"SLA"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"SLA"> | $Enums.Priority
    response_time?: IntWithAggregatesFilter<"SLA"> | number
    resolution_time?: IntWithAggregatesFilter<"SLA"> | number
    is_active?: BoolWithAggregatesFilter<"SLA"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"SLA"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"SLA"> | Date | string
  }

  export type TicketStatisticsWhereInput = {
    AND?: TicketStatisticsWhereInput | TicketStatisticsWhereInput[]
    OR?: TicketStatisticsWhereInput[]
    NOT?: TicketStatisticsWhereInput | TicketStatisticsWhereInput[]
    id?: IntFilter<"TicketStatistics"> | number
    date?: DateTimeFilter<"TicketStatistics"> | Date | string
    total_tickets?: IntFilter<"TicketStatistics"> | number
    open_tickets?: IntFilter<"TicketStatistics"> | number
    resolved_tickets?: IntFilter<"TicketStatistics"> | number
    closed_tickets?: IntFilter<"TicketStatistics"> | number
    avg_resolution_time?: FloatFilter<"TicketStatistics"> | number
    avg_satisfaction?: FloatFilter<"TicketStatistics"> | number
    created_at?: DateTimeFilter<"TicketStatistics"> | Date | string
  }

  export type TicketStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
    created_at?: SortOrder
  }

  export type TicketStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    date?: Date | string
    AND?: TicketStatisticsWhereInput | TicketStatisticsWhereInput[]
    OR?: TicketStatisticsWhereInput[]
    NOT?: TicketStatisticsWhereInput | TicketStatisticsWhereInput[]
    total_tickets?: IntFilter<"TicketStatistics"> | number
    open_tickets?: IntFilter<"TicketStatistics"> | number
    resolved_tickets?: IntFilter<"TicketStatistics"> | number
    closed_tickets?: IntFilter<"TicketStatistics"> | number
    avg_resolution_time?: FloatFilter<"TicketStatistics"> | number
    avg_satisfaction?: FloatFilter<"TicketStatistics"> | number
    created_at?: DateTimeFilter<"TicketStatistics"> | Date | string
  }, "id" | "id" | "date">

  export type TicketStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
    created_at?: SortOrder
    _count?: TicketStatisticsCountOrderByAggregateInput
    _avg?: TicketStatisticsAvgOrderByAggregateInput
    _max?: TicketStatisticsMaxOrderByAggregateInput
    _min?: TicketStatisticsMinOrderByAggregateInput
    _sum?: TicketStatisticsSumOrderByAggregateInput
  }

  export type TicketStatisticsScalarWhereWithAggregatesInput = {
    AND?: TicketStatisticsScalarWhereWithAggregatesInput | TicketStatisticsScalarWhereWithAggregatesInput[]
    OR?: TicketStatisticsScalarWhereWithAggregatesInput[]
    NOT?: TicketStatisticsScalarWhereWithAggregatesInput | TicketStatisticsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketStatistics"> | number
    date?: DateTimeWithAggregatesFilter<"TicketStatistics"> | Date | string
    total_tickets?: IntWithAggregatesFilter<"TicketStatistics"> | number
    open_tickets?: IntWithAggregatesFilter<"TicketStatistics"> | number
    resolved_tickets?: IntWithAggregatesFilter<"TicketStatistics"> | number
    closed_tickets?: IntWithAggregatesFilter<"TicketStatistics"> | number
    avg_resolution_time?: FloatWithAggregatesFilter<"TicketStatistics"> | number
    avg_satisfaction?: FloatWithAggregatesFilter<"TicketStatistics"> | number
    created_at?: DateTimeWithAggregatesFilter<"TicketStatistics"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgentCreateInput = {
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: number
    user_id: number
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: number
    user_id: number
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    user_id: number
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    user_id: number
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    response_templates?: ResponseTemplateCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    response_templates?: ResponseTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    response_templates?: ResponseTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    response_templates?: ResponseTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubcategoryCreateInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
    tickets?: TicketCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category_id: number
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    tickets?: TicketUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category_id: number
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SubcategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubcategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
  }

  export type TicketUpdateManyMutationInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateInput = {
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTicket_commentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    ticket_id: number
    user_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTicket_commentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    ticket_id: number
    user_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    created_at?: Date | string
    ticket?: TicketCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    ticket_id?: number | null
    comment_id?: number | null
    created_at?: Date | string
  }

  export type AttachmentUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    ticket_id?: number | null
    comment_id?: number | null
    created_at?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketHistoryCreateInput = {
    field_name: string
    old_value?: string | null
    new_value?: string | null
    created_at?: Date | string
    ticket: TicketCreateNestedOneWithoutTicket_historyInput
    user: UserCreateNestedOneWithoutTicket_historyInput
  }

  export type TicketHistoryUncheckedCreateInput = {
    id?: number
    ticket_id: number
    field_name: string
    old_value?: string | null
    new_value?: string | null
    changed_by: number
    created_at?: Date | string
  }

  export type TicketHistoryUpdateInput = {
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicket_historyNestedInput
    user?: UserUpdateOneRequiredWithoutTicket_historyNestedInput
  }

  export type TicketHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    changed_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketHistoryCreateManyInput = {
    id?: number
    ticket_id: number
    field_name: string
    old_value?: string | null
    new_value?: string | null
    changed_by: number
    created_at?: Date | string
  }

  export type TicketHistoryUpdateManyMutationInput = {
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    changed_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAssignmentCreateInput = {
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
    ticket: TicketCreateNestedOneWithoutTicket_assignmentsInput
    agent: AgentCreateNestedOneWithoutTicket_assignmentsInput
    assigned_by_user: UserCreateNestedOneWithoutTicket_assignmentsInput
  }

  export type TicketAssignmentUncheckedCreateInput = {
    id?: number
    ticket_id: number
    agent_id: number
    assigned_by: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketAssignmentUpdateInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ticket?: TicketUpdateOneRequiredWithoutTicket_assignmentsNestedInput
    agent?: AgentUpdateOneRequiredWithoutTicket_assignmentsNestedInput
    assigned_by_user?: UserUpdateOneRequiredWithoutTicket_assignmentsNestedInput
  }

  export type TicketAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    agent_id?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAssignmentCreateManyInput = {
    id?: number
    ticket_id: number
    agent_id: number
    assigned_by: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketAssignmentUpdateManyMutationInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    agent_id?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemSettingsCreateInput = {
    setting_key: string
    setting_value: string
    description?: string | null
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: number
    setting_key: string
    setting_value: string
    description?: string | null
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    setting_key?: StringFieldUpdateOperationsInput | string
    setting_value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_key?: StringFieldUpdateOperationsInput | string
    setting_value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: number
    setting_key: string
    setting_value: string
    description?: string | null
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    setting_key?: StringFieldUpdateOperationsInput | string
    setting_value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_key?: StringFieldUpdateOperationsInput | string
    setting_value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseTemplateCreateInput = {
    name: string
    subject: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    category?: CategoryCreateNestedOneWithoutResponse_templatesInput
  }

  export type ResponseTemplateUncheckedCreateInput = {
    id?: number
    name: string
    subject: string
    content: string
    category_id?: number | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ResponseTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutResponse_templatesNestedInput
  }

  export type ResponseTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseTemplateCreateManyInput = {
    id?: number
    name: string
    subject: string
    content: string
    category_id?: number | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ResponseTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SLACreateInput = {
    name: string
    description?: string | null
    priority: $Enums.Priority
    response_time: number
    resolution_time: number
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SLAUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    priority: $Enums.Priority
    response_time: number
    resolution_time: number
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SLAUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    response_time?: IntFieldUpdateOperationsInput | number
    resolution_time?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SLAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    response_time?: IntFieldUpdateOperationsInput | number
    resolution_time?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SLACreateManyInput = {
    id?: number
    name: string
    description?: string | null
    priority: $Enums.Priority
    response_time: number
    resolution_time: number
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SLAUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    response_time?: IntFieldUpdateOperationsInput | number
    resolution_time?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SLAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    response_time?: IntFieldUpdateOperationsInput | number
    resolution_time?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketStatisticsCreateInput = {
    date: Date | string
    total_tickets?: number
    open_tickets?: number
    resolved_tickets?: number
    closed_tickets?: number
    avg_resolution_time?: number
    avg_satisfaction?: number
    created_at?: Date | string
  }

  export type TicketStatisticsUncheckedCreateInput = {
    id?: number
    date: Date | string
    total_tickets?: number
    open_tickets?: number
    resolved_tickets?: number
    closed_tickets?: number
    avg_resolution_time?: number
    avg_satisfaction?: number
    created_at?: Date | string
  }

  export type TicketStatisticsUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_tickets?: IntFieldUpdateOperationsInput | number
    open_tickets?: IntFieldUpdateOperationsInput | number
    resolved_tickets?: IntFieldUpdateOperationsInput | number
    closed_tickets?: IntFieldUpdateOperationsInput | number
    avg_resolution_time?: FloatFieldUpdateOperationsInput | number
    avg_satisfaction?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketStatisticsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_tickets?: IntFieldUpdateOperationsInput | number
    open_tickets?: IntFieldUpdateOperationsInput | number
    resolved_tickets?: IntFieldUpdateOperationsInput | number
    closed_tickets?: IntFieldUpdateOperationsInput | number
    avg_resolution_time?: FloatFieldUpdateOperationsInput | number
    avg_satisfaction?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketStatisticsCreateManyInput = {
    id?: number
    date: Date | string
    total_tickets?: number
    open_tickets?: number
    resolved_tickets?: number
    closed_tickets?: number
    avg_resolution_time?: number
    avg_satisfaction?: number
    created_at?: Date | string
  }

  export type TicketStatisticsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_tickets?: IntFieldUpdateOperationsInput | number
    open_tickets?: IntFieldUpdateOperationsInput | number
    resolved_tickets?: IntFieldUpdateOperationsInput | number
    closed_tickets?: IntFieldUpdateOperationsInput | number
    avg_resolution_time?: FloatFieldUpdateOperationsInput | number
    avg_satisfaction?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketStatisticsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_tickets?: IntFieldUpdateOperationsInput | number
    open_tickets?: IntFieldUpdateOperationsInput | number
    resolved_tickets?: IntFieldUpdateOperationsInput | number
    closed_tickets?: IntFieldUpdateOperationsInput | number
    avg_resolution_time?: FloatFieldUpdateOperationsInput | number
    avg_satisfaction?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type TicketAssignmentListRelationFilter = {
    every?: TicketAssignmentWhereInput
    some?: TicketAssignmentWhereInput
    none?: TicketAssignmentWhereInput
  }

  export type TicketHistoryListRelationFilter = {
    every?: TicketHistoryWhereInput
    some?: TicketHistoryWhereInput
    none?: TicketHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    role?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    role?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    role?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    employee_id?: SortOrder
    department?: SortOrder
    skills?: SortOrder
    max_tickets?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    max_tickets?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    employee_id?: SortOrder
    department?: SortOrder
    max_tickets?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    employee_id?: SortOrder
    department?: SortOrder
    max_tickets?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    max_tickets?: SortOrder
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company?: SortOrder
    client_type?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company?: SortOrder
    client_type?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company?: SortOrder
    client_type?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type SubcategoryListRelationFilter = {
    every?: SubcategoryWhereInput
    some?: SubcategoryWhereInput
    none?: SubcategoryWhereInput
  }

  export type ResponseTemplateListRelationFilter = {
    every?: ResponseTemplateWhereInput
    some?: ResponseTemplateWhereInput
    none?: ResponseTemplateWhereInput
  }

  export type SubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResponseTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SubcategoryNameCategory_idCompoundUniqueInput = {
    name: string
    category_id: number
  }

  export type SubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SubcategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type SubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SubcategorySumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SubcategoryNullableScalarRelationFilter = {
    is?: SubcategoryWhereInput | null
    isNot?: SubcategoryWhereInput | null
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrder
    due_date?: SortOrder
    resolution_time?: SortOrder
    satisfaction_rating?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    closed_at?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrder
    resolution_time?: SortOrder
    satisfaction_rating?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrder
    due_date?: SortOrder
    resolution_time?: SortOrder
    satisfaction_rating?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    closed_at?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrder
    due_date?: SortOrder
    resolution_time?: SortOrder
    satisfaction_rating?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    closed_at?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    subcategory_id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    assigned_to?: SortOrder
    resolution_time?: SortOrder
    satisfaction_rating?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    user_id?: SortOrder
  }

  export type TicketNullableScalarRelationFilter = {
    is?: TicketWhereInput | null
    isNot?: TicketWhereInput | null
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    original_name?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    ticket_id?: SortOrder
    comment_id?: SortOrder
    created_at?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    file_size?: SortOrder
    ticket_id?: SortOrder
    comment_id?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    original_name?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    ticket_id?: SortOrder
    comment_id?: SortOrder
    created_at?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    original_name?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    mime_type?: SortOrder
    ticket_id?: SortOrder
    comment_id?: SortOrder
    created_at?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    file_size?: SortOrder
    ticket_id?: SortOrder
    comment_id?: SortOrder
  }

  export type TicketHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    field_name?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    changed_by?: SortOrder
    created_at?: SortOrder
  }

  export type TicketHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    changed_by?: SortOrder
  }

  export type TicketHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    field_name?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    changed_by?: SortOrder
    created_at?: SortOrder
  }

  export type TicketHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    field_name?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    changed_by?: SortOrder
    created_at?: SortOrder
  }

  export type TicketHistorySumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    changed_by?: SortOrder
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type TicketAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
    assigned_at?: SortOrder
    unassigned_at?: SortOrder
  }

  export type TicketAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
  }

  export type TicketAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
    assigned_at?: SortOrder
    unassigned_at?: SortOrder
  }

  export type TicketAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
    assigned_at?: SortOrder
    unassigned_at?: SortOrder
  }

  export type TicketAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    agent_id?: SortOrder
    assigned_by?: SortOrder
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    setting_key?: SortOrder
    setting_value?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SystemSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    setting_key?: SortOrder
    setting_value?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    setting_key?: SortOrder
    setting_value?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SystemSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ResponseTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ResponseTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type ResponseTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ResponseTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    category_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ResponseTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type SLACountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SLAAvgOrderByAggregateInput = {
    id?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
  }

  export type SLAMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SLAMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type SLASumOrderByAggregateInput = {
    id?: SortOrder
    response_time?: SortOrder
    resolution_time?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TicketStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
    created_at?: SortOrder
  }

  export type TicketStatisticsAvgOrderByAggregateInput = {
    id?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
  }

  export type TicketStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
    created_at?: SortOrder
  }

  export type TicketStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
    created_at?: SortOrder
  }

  export type TicketStatisticsSumOrderByAggregateInput = {
    id?: SortOrder
    total_tickets?: SortOrder
    open_tickets?: SortOrder
    resolved_tickets?: SortOrder
    closed_tickets?: SortOrder
    avg_resolution_time?: SortOrder
    avg_satisfaction?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AgentCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TicketCreateWithoutCreatorInput, TicketUncheckedCreateWithoutCreatorInput> | TicketCreateWithoutCreatorInput[] | TicketUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatorInput | TicketCreateOrConnectWithoutCreatorInput[]
    createMany?: TicketCreateManyCreatorInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput = {
    create?: XOR<TicketAssignmentCreateWithoutAssigned_by_userInput, TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput> | TicketAssignmentCreateWithoutAssigned_by_userInput[] | TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput | TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput[]
    createMany?: TicketAssignmentCreateManyAssigned_by_userInputEnvelope
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
  }

  export type TicketHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type TicketUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TicketCreateWithoutCreatorInput, TicketUncheckedCreateWithoutCreatorInput> | TicketCreateWithoutCreatorInput[] | TicketUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatorInput | TicketCreateOrConnectWithoutCreatorInput[]
    createMany?: TicketCreateManyCreatorInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput = {
    create?: XOR<TicketAssignmentCreateWithoutAssigned_by_userInput, TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput> | TicketAssignmentCreateWithoutAssigned_by_userInput[] | TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput | TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput[]
    createMany?: TicketAssignmentCreateManyAssigned_by_userInputEnvelope
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
  }

  export type TicketHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AgentUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TicketCreateWithoutCreatorInput, TicketUncheckedCreateWithoutCreatorInput> | TicketCreateWithoutCreatorInput[] | TicketUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatorInput | TicketCreateOrConnectWithoutCreatorInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCreatorInput | TicketUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TicketCreateManyCreatorInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCreatorInput | TicketUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCreatorInput | TicketUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssigneeInput | TicketUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssigneeInput | TicketUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssigneeInput | TicketUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput = {
    create?: XOR<TicketAssignmentCreateWithoutAssigned_by_userInput, TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput> | TicketAssignmentCreateWithoutAssigned_by_userInput[] | TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput | TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput[]
    upsert?: TicketAssignmentUpsertWithWhereUniqueWithoutAssigned_by_userInput | TicketAssignmentUpsertWithWhereUniqueWithoutAssigned_by_userInput[]
    createMany?: TicketAssignmentCreateManyAssigned_by_userInputEnvelope
    set?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    disconnect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    delete?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    update?: TicketAssignmentUpdateWithWhereUniqueWithoutAssigned_by_userInput | TicketAssignmentUpdateWithWhereUniqueWithoutAssigned_by_userInput[]
    updateMany?: TicketAssignmentUpdateManyWithWhereWithoutAssigned_by_userInput | TicketAssignmentUpdateManyWithWhereWithoutAssigned_by_userInput[]
    deleteMany?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
  }

  export type TicketHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutUserInput | TicketHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutUserInput | TicketHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutUserInput | TicketHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type TicketUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TicketCreateWithoutCreatorInput, TicketUncheckedCreateWithoutCreatorInput> | TicketCreateWithoutCreatorInput[] | TicketUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatorInput | TicketCreateOrConnectWithoutCreatorInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCreatorInput | TicketUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TicketCreateManyCreatorInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCreatorInput | TicketUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCreatorInput | TicketUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput> | TicketCreateWithoutAssigneeInput[] | TicketUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssigneeInput | TicketCreateOrConnectWithoutAssigneeInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssigneeInput | TicketUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TicketCreateManyAssigneeInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssigneeInput | TicketUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssigneeInput | TicketUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput = {
    create?: XOR<TicketAssignmentCreateWithoutAssigned_by_userInput, TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput> | TicketAssignmentCreateWithoutAssigned_by_userInput[] | TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput | TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput[]
    upsert?: TicketAssignmentUpsertWithWhereUniqueWithoutAssigned_by_userInput | TicketAssignmentUpsertWithWhereUniqueWithoutAssigned_by_userInput[]
    createMany?: TicketAssignmentCreateManyAssigned_by_userInputEnvelope
    set?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    disconnect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    delete?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    update?: TicketAssignmentUpdateWithWhereUniqueWithoutAssigned_by_userInput | TicketAssignmentUpdateWithWhereUniqueWithoutAssigned_by_userInput[]
    updateMany?: TicketAssignmentUpdateManyWithWhereWithoutAssigned_by_userInput | TicketAssignmentUpdateManyWithWhereWithoutAssigned_by_userInput[]
    deleteMany?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
  }

  export type TicketHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput> | TicketHistoryCreateWithoutUserInput[] | TicketHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutUserInput | TicketHistoryCreateOrConnectWithoutUserInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutUserInput | TicketHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketHistoryCreateManyUserInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutUserInput | TicketHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutUserInput | TicketHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type AgentCreateskillsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAgentInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    connect?: UserWhereUniqueInput
  }

  export type TicketAssignmentCreateNestedManyWithoutAgentInput = {
    create?: XOR<TicketAssignmentCreateWithoutAgentInput, TicketAssignmentUncheckedCreateWithoutAgentInput> | TicketAssignmentCreateWithoutAgentInput[] | TicketAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAgentInput | TicketAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: TicketAssignmentCreateManyAgentInputEnvelope
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
  }

  export type TicketAssignmentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TicketAssignmentCreateWithoutAgentInput, TicketAssignmentUncheckedCreateWithoutAgentInput> | TicketAssignmentCreateWithoutAgentInput[] | TicketAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAgentInput | TicketAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: TicketAssignmentCreateManyAgentInputEnvelope
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
  }

  export type AgentUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAgentNestedInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    upsert?: UserUpsertWithoutAgentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentInput, UserUpdateWithoutAgentInput>, UserUncheckedUpdateWithoutAgentInput>
  }

  export type TicketAssignmentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TicketAssignmentCreateWithoutAgentInput, TicketAssignmentUncheckedCreateWithoutAgentInput> | TicketAssignmentCreateWithoutAgentInput[] | TicketAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAgentInput | TicketAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: TicketAssignmentUpsertWithWhereUniqueWithoutAgentInput | TicketAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TicketAssignmentCreateManyAgentInputEnvelope
    set?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    disconnect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    delete?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    update?: TicketAssignmentUpdateWithWhereUniqueWithoutAgentInput | TicketAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TicketAssignmentUpdateManyWithWhereWithoutAgentInput | TicketAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
  }

  export type TicketAssignmentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TicketAssignmentCreateWithoutAgentInput, TicketAssignmentUncheckedCreateWithoutAgentInput> | TicketAssignmentCreateWithoutAgentInput[] | TicketAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutAgentInput | TicketAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: TicketAssignmentUpsertWithWhereUniqueWithoutAgentInput | TicketAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TicketAssignmentCreateManyAgentInputEnvelope
    set?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    disconnect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    delete?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    update?: TicketAssignmentUpdateWithWhereUniqueWithoutAgentInput | TicketAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TicketAssignmentUpdateManyWithWhereWithoutAgentInput | TicketAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type UserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type TicketUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type SubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type ResponseTemplateCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ResponseTemplateCreateWithoutCategoryInput, ResponseTemplateUncheckedCreateWithoutCategoryInput> | ResponseTemplateCreateWithoutCategoryInput[] | ResponseTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResponseTemplateCreateOrConnectWithoutCategoryInput | ResponseTemplateCreateOrConnectWithoutCategoryInput[]
    createMany?: ResponseTemplateCreateManyCategoryInputEnvelope
    connect?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type SubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type ResponseTemplateUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ResponseTemplateCreateWithoutCategoryInput, ResponseTemplateUncheckedCreateWithoutCategoryInput> | ResponseTemplateCreateWithoutCategoryInput[] | ResponseTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResponseTemplateCreateOrConnectWithoutCategoryInput | ResponseTemplateCreateOrConnectWithoutCategoryInput[]
    createMany?: ResponseTemplateCreateManyCategoryInputEnvelope
    connect?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
  }

  export type TicketUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCategoryInput | TicketUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCategoryInput | TicketUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCategoryInput | TicketUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type SubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type ResponseTemplateUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ResponseTemplateCreateWithoutCategoryInput, ResponseTemplateUncheckedCreateWithoutCategoryInput> | ResponseTemplateCreateWithoutCategoryInput[] | ResponseTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResponseTemplateCreateOrConnectWithoutCategoryInput | ResponseTemplateCreateOrConnectWithoutCategoryInput[]
    upsert?: ResponseTemplateUpsertWithWhereUniqueWithoutCategoryInput | ResponseTemplateUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ResponseTemplateCreateManyCategoryInputEnvelope
    set?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    disconnect?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    delete?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    connect?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    update?: ResponseTemplateUpdateWithWhereUniqueWithoutCategoryInput | ResponseTemplateUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ResponseTemplateUpdateManyWithWhereWithoutCategoryInput | ResponseTemplateUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ResponseTemplateScalarWhereInput | ResponseTemplateScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCategoryInput | TicketUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCategoryInput | TicketUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCategoryInput | TicketUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type ResponseTemplateUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ResponseTemplateCreateWithoutCategoryInput, ResponseTemplateUncheckedCreateWithoutCategoryInput> | ResponseTemplateCreateWithoutCategoryInput[] | ResponseTemplateUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResponseTemplateCreateOrConnectWithoutCategoryInput | ResponseTemplateCreateOrConnectWithoutCategoryInput[]
    upsert?: ResponseTemplateUpsertWithWhereUniqueWithoutCategoryInput | ResponseTemplateUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ResponseTemplateCreateManyCategoryInputEnvelope
    set?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    disconnect?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    delete?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    connect?: ResponseTemplateWhereUniqueInput | ResponseTemplateWhereUniqueInput[]
    update?: ResponseTemplateUpdateWithWhereUniqueWithoutCategoryInput | ResponseTemplateUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ResponseTemplateUpdateManyWithWhereWithoutCategoryInput | ResponseTemplateUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ResponseTemplateScalarWhereInput | ResponseTemplateScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<TicketCreateWithoutSubcategoryInput, TicketUncheckedCreateWithoutSubcategoryInput> | TicketCreateWithoutSubcategoryInput[] | TicketUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSubcategoryInput | TicketCreateOrConnectWithoutSubcategoryInput[]
    createMany?: TicketCreateManySubcategoryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<TicketCreateWithoutSubcategoryInput, TicketUncheckedCreateWithoutSubcategoryInput> | TicketCreateWithoutSubcategoryInput[] | TicketUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSubcategoryInput | TicketCreateOrConnectWithoutSubcategoryInput[]
    createMany?: TicketCreateManySubcategoryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: CategoryUpsertWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubcategoriesInput, CategoryUpdateWithoutSubcategoriesInput>, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type TicketUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<TicketCreateWithoutSubcategoryInput, TicketUncheckedCreateWithoutSubcategoryInput> | TicketCreateWithoutSubcategoryInput[] | TicketUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSubcategoryInput | TicketCreateOrConnectWithoutSubcategoryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSubcategoryInput | TicketUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: TicketCreateManySubcategoryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSubcategoryInput | TicketUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSubcategoryInput | TicketUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<TicketCreateWithoutSubcategoryInput, TicketUncheckedCreateWithoutSubcategoryInput> | TicketCreateWithoutSubcategoryInput[] | TicketUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSubcategoryInput | TicketCreateOrConnectWithoutSubcategoryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSubcategoryInput | TicketUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: TicketCreateManySubcategoryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSubcategoryInput | TicketUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSubcategoryInput | TicketUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutTicketsInput = {
    create?: XOR<CategoryCreateWithoutTicketsInput, CategoryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTicketsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SubcategoryCreateNestedOneWithoutTicketsInput = {
    create?: XOR<SubcategoryCreateWithoutTicketsInput, SubcategoryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutTicketsInput
    connect?: SubcategoryWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTicketsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTickets_createdInput = {
    create?: XOR<UserCreateWithoutTickets_createdInput, UserUncheckedCreateWithoutTickets_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutTickets_createdInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTickets_assignedInput = {
    create?: XOR<UserCreateWithoutTickets_assignedInput, UserUncheckedCreateWithoutTickets_assignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTickets_assignedInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<CommentCreateWithoutTicketInput, CommentUncheckedCreateWithoutTicketInput> | CommentCreateWithoutTicketInput[] | CommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTicketInput | CommentCreateOrConnectWithoutTicketInput[]
    createMany?: CommentCreateManyTicketInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<AttachmentCreateWithoutTicketInput, AttachmentUncheckedCreateWithoutTicketInput> | AttachmentCreateWithoutTicketInput[] | AttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTicketInput | AttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: AttachmentCreateManyTicketInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TicketHistoryCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type TicketAssignmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAssignmentCreateWithoutTicketInput, TicketAssignmentUncheckedCreateWithoutTicketInput> | TicketAssignmentCreateWithoutTicketInput[] | TicketAssignmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutTicketInput | TicketAssignmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAssignmentCreateManyTicketInputEnvelope
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<CommentCreateWithoutTicketInput, CommentUncheckedCreateWithoutTicketInput> | CommentCreateWithoutTicketInput[] | CommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTicketInput | CommentCreateOrConnectWithoutTicketInput[]
    createMany?: CommentCreateManyTicketInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<AttachmentCreateWithoutTicketInput, AttachmentUncheckedCreateWithoutTicketInput> | AttachmentCreateWithoutTicketInput[] | AttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTicketInput | AttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: AttachmentCreateManyTicketInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TicketHistoryUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
  }

  export type TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAssignmentCreateWithoutTicketInput, TicketAssignmentUncheckedCreateWithoutTicketInput> | TicketAssignmentCreateWithoutTicketInput[] | TicketAssignmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutTicketInput | TicketAssignmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAssignmentCreateManyTicketInputEnvelope
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<CategoryCreateWithoutTicketsInput, CategoryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTicketsInput
    upsert?: CategoryUpsertWithoutTicketsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTicketsInput, CategoryUpdateWithoutTicketsInput>, CategoryUncheckedUpdateWithoutTicketsInput>
  }

  export type SubcategoryUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<SubcategoryCreateWithoutTicketsInput, SubcategoryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutTicketsInput
    upsert?: SubcategoryUpsertWithoutTicketsInput
    disconnect?: SubcategoryWhereInput | boolean
    delete?: SubcategoryWhereInput | boolean
    connect?: SubcategoryWhereUniqueInput
    update?: XOR<XOR<SubcategoryUpdateToOneWithWhereWithoutTicketsInput, SubcategoryUpdateWithoutTicketsInput>, SubcategoryUncheckedUpdateWithoutTicketsInput>
  }

  export type ClientUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTicketsInput
    upsert?: ClientUpsertWithoutTicketsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTicketsInput, ClientUpdateWithoutTicketsInput>, ClientUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutTickets_createdNestedInput = {
    create?: XOR<UserCreateWithoutTickets_createdInput, UserUncheckedCreateWithoutTickets_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutTickets_createdInput
    upsert?: UserUpsertWithoutTickets_createdInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTickets_createdInput, UserUpdateWithoutTickets_createdInput>, UserUncheckedUpdateWithoutTickets_createdInput>
  }

  export type UserUpdateOneWithoutTickets_assignedNestedInput = {
    create?: XOR<UserCreateWithoutTickets_assignedInput, UserUncheckedCreateWithoutTickets_assignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTickets_assignedInput
    upsert?: UserUpsertWithoutTickets_assignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTickets_assignedInput, UserUpdateWithoutTickets_assignedInput>, UserUncheckedUpdateWithoutTickets_assignedInput>
  }

  export type CommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<CommentCreateWithoutTicketInput, CommentUncheckedCreateWithoutTicketInput> | CommentCreateWithoutTicketInput[] | CommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTicketInput | CommentCreateOrConnectWithoutTicketInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTicketInput | CommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: CommentCreateManyTicketInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTicketInput | CommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTicketInput | CommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<AttachmentCreateWithoutTicketInput, AttachmentUncheckedCreateWithoutTicketInput> | AttachmentCreateWithoutTicketInput[] | AttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTicketInput | AttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTicketInput | AttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: AttachmentCreateManyTicketInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTicketInput | AttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTicketInput | AttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TicketHistoryUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutTicketInput | TicketHistoryUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutTicketInput | TicketHistoryUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutTicketInput | TicketHistoryUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type TicketAssignmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAssignmentCreateWithoutTicketInput, TicketAssignmentUncheckedCreateWithoutTicketInput> | TicketAssignmentCreateWithoutTicketInput[] | TicketAssignmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutTicketInput | TicketAssignmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAssignmentUpsertWithWhereUniqueWithoutTicketInput | TicketAssignmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAssignmentCreateManyTicketInputEnvelope
    set?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    disconnect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    delete?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    update?: TicketAssignmentUpdateWithWhereUniqueWithoutTicketInput | TicketAssignmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAssignmentUpdateManyWithWhereWithoutTicketInput | TicketAssignmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<CommentCreateWithoutTicketInput, CommentUncheckedCreateWithoutTicketInput> | CommentCreateWithoutTicketInput[] | CommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTicketInput | CommentCreateOrConnectWithoutTicketInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTicketInput | CommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: CommentCreateManyTicketInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTicketInput | CommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTicketInput | CommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<AttachmentCreateWithoutTicketInput, AttachmentUncheckedCreateWithoutTicketInput> | AttachmentCreateWithoutTicketInput[] | AttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTicketInput | AttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTicketInput | AttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: AttachmentCreateManyTicketInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTicketInput | AttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTicketInput | AttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput> | TicketHistoryCreateWithoutTicketInput[] | TicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketHistoryCreateOrConnectWithoutTicketInput | TicketHistoryCreateOrConnectWithoutTicketInput[]
    upsert?: TicketHistoryUpsertWithWhereUniqueWithoutTicketInput | TicketHistoryUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketHistoryCreateManyTicketInputEnvelope
    set?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    disconnect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    delete?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    connect?: TicketHistoryWhereUniqueInput | TicketHistoryWhereUniqueInput[]
    update?: TicketHistoryUpdateWithWhereUniqueWithoutTicketInput | TicketHistoryUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketHistoryUpdateManyWithWhereWithoutTicketInput | TicketHistoryUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
  }

  export type TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAssignmentCreateWithoutTicketInput, TicketAssignmentUncheckedCreateWithoutTicketInput> | TicketAssignmentCreateWithoutTicketInput[] | TicketAssignmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAssignmentCreateOrConnectWithoutTicketInput | TicketAssignmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAssignmentUpsertWithWhereUniqueWithoutTicketInput | TicketAssignmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAssignmentCreateManyTicketInputEnvelope
    set?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    disconnect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    delete?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    connect?: TicketAssignmentWhereUniqueInput | TicketAssignmentWhereUniqueInput[]
    update?: TicketAssignmentUpdateWithWhereUniqueWithoutTicketInput | TicketAssignmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAssignmentUpdateManyWithWhereWithoutTicketInput | TicketAssignmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicket_commentsInput = {
    create?: XOR<UserCreateWithoutTicket_commentsInput, UserUncheckedCreateWithoutTicket_commentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_commentsInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutCommentInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    upsert?: TicketUpsertWithoutCommentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutCommentsInput, TicketUpdateWithoutCommentsInput>, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicket_commentsNestedInput = {
    create?: XOR<UserCreateWithoutTicket_commentsInput, UserUncheckedCreateWithoutTicket_commentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_commentsInput
    upsert?: UserUpsertWithoutTicket_commentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicket_commentsInput, UserUpdateWithoutTicket_commentsInput>, UserUncheckedUpdateWithoutTicket_commentsInput>
  }

  export type AttachmentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommentInput | AttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommentInput | AttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommentInput | AttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommentInput | AttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommentInput | AttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommentInput | AttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutAttachmentsInput
    connect?: CommentWhereUniqueInput
  }

  export type TicketUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    upsert?: TicketUpsertWithoutAttachmentsInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutAttachmentsInput, TicketUpdateWithoutAttachmentsInput>, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommentUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutAttachmentsInput
    upsert?: CommentUpsertWithoutAttachmentsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutAttachmentsInput, CommentUpdateWithoutAttachmentsInput>, CommentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketCreateNestedOneWithoutTicket_historyInput = {
    create?: XOR<TicketCreateWithoutTicket_historyInput, TicketUncheckedCreateWithoutTicket_historyInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicket_historyInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicket_historyInput = {
    create?: XOR<UserCreateWithoutTicket_historyInput, UserUncheckedCreateWithoutTicket_historyInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_historyInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutTicket_historyNestedInput = {
    create?: XOR<TicketCreateWithoutTicket_historyInput, TicketUncheckedCreateWithoutTicket_historyInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicket_historyInput
    upsert?: TicketUpsertWithoutTicket_historyInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicket_historyInput, TicketUpdateWithoutTicket_historyInput>, TicketUncheckedUpdateWithoutTicket_historyInput>
  }

  export type UserUpdateOneRequiredWithoutTicket_historyNestedInput = {
    create?: XOR<UserCreateWithoutTicket_historyInput, UserUncheckedCreateWithoutTicket_historyInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_historyInput
    upsert?: UserUpsertWithoutTicket_historyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicket_historyInput, UserUpdateWithoutTicket_historyInput>, UserUncheckedUpdateWithoutTicket_historyInput>
  }

  export type TicketCreateNestedOneWithoutTicket_assignmentsInput = {
    create?: XOR<TicketCreateWithoutTicket_assignmentsInput, TicketUncheckedCreateWithoutTicket_assignmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicket_assignmentsInput
    connect?: TicketWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutTicket_assignmentsInput = {
    create?: XOR<AgentCreateWithoutTicket_assignmentsInput, AgentUncheckedCreateWithoutTicket_assignmentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTicket_assignmentsInput
    connect?: AgentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicket_assignmentsInput = {
    create?: XOR<UserCreateWithoutTicket_assignmentsInput, UserUncheckedCreateWithoutTicket_assignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_assignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutTicket_assignmentsNestedInput = {
    create?: XOR<TicketCreateWithoutTicket_assignmentsInput, TicketUncheckedCreateWithoutTicket_assignmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicket_assignmentsInput
    upsert?: TicketUpsertWithoutTicket_assignmentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicket_assignmentsInput, TicketUpdateWithoutTicket_assignmentsInput>, TicketUncheckedUpdateWithoutTicket_assignmentsInput>
  }

  export type AgentUpdateOneRequiredWithoutTicket_assignmentsNestedInput = {
    create?: XOR<AgentCreateWithoutTicket_assignmentsInput, AgentUncheckedCreateWithoutTicket_assignmentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTicket_assignmentsInput
    upsert?: AgentUpsertWithoutTicket_assignmentsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTicket_assignmentsInput, AgentUpdateWithoutTicket_assignmentsInput>, AgentUncheckedUpdateWithoutTicket_assignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicket_assignmentsNestedInput = {
    create?: XOR<UserCreateWithoutTicket_assignmentsInput, UserUncheckedCreateWithoutTicket_assignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicket_assignmentsInput
    upsert?: UserUpsertWithoutTicket_assignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicket_assignmentsInput, UserUpdateWithoutTicket_assignmentsInput>, UserUncheckedUpdateWithoutTicket_assignmentsInput>
  }

  export type CategoryCreateNestedOneWithoutResponse_templatesInput = {
    create?: XOR<CategoryCreateWithoutResponse_templatesInput, CategoryUncheckedCreateWithoutResponse_templatesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutResponse_templatesInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryUpdateOneWithoutResponse_templatesNestedInput = {
    create?: XOR<CategoryCreateWithoutResponse_templatesInput, CategoryUncheckedCreateWithoutResponse_templatesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutResponse_templatesInput
    upsert?: CategoryUpsertWithoutResponse_templatesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutResponse_templatesInput, CategoryUpdateWithoutResponse_templatesInput>, CategoryUncheckedUpdateWithoutResponse_templatesInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AgentCreateWithoutUserInput = {
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: number
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateWithoutUserInput = {
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: number
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateWithoutCreatorInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutCreatorInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutCreatorInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCreatorInput, TicketUncheckedCreateWithoutCreatorInput>
  }

  export type TicketCreateManyCreatorInputEnvelope = {
    data: TicketCreateManyCreatorInput | TicketCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssigneeInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAssigneeInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAssigneeInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput>
  }

  export type TicketCreateManyAssigneeInputEnvelope = {
    data: TicketCreateManyAssigneeInput | TicketCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    ticket_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketAssignmentCreateWithoutAssigned_by_userInput = {
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
    ticket: TicketCreateNestedOneWithoutTicket_assignmentsInput
    agent: AgentCreateNestedOneWithoutTicket_assignmentsInput
  }

  export type TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput = {
    id?: number
    ticket_id: number
    agent_id: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketAssignmentCreateOrConnectWithoutAssigned_by_userInput = {
    where: TicketAssignmentWhereUniqueInput
    create: XOR<TicketAssignmentCreateWithoutAssigned_by_userInput, TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput>
  }

  export type TicketAssignmentCreateManyAssigned_by_userInputEnvelope = {
    data: TicketAssignmentCreateManyAssigned_by_userInput | TicketAssignmentCreateManyAssigned_by_userInput[]
    skipDuplicates?: boolean
  }

  export type TicketHistoryCreateWithoutUserInput = {
    field_name: string
    old_value?: string | null
    new_value?: string | null
    created_at?: Date | string
    ticket: TicketCreateNestedOneWithoutTicket_historyInput
  }

  export type TicketHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    ticket_id: number
    field_name: string
    old_value?: string | null
    new_value?: string | null
    created_at?: Date | string
  }

  export type TicketHistoryCreateOrConnectWithoutUserInput = {
    where: TicketHistoryWhereUniqueInput
    create: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput>
  }

  export type TicketHistoryCreateManyUserInputEnvelope = {
    data: TicketHistoryCreateManyUserInput | TicketHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutUserInput = {
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutUserInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateWithoutUserInput = {
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCreatorInput, TicketUncheckedUpdateWithoutCreatorInput>
    create: XOR<TicketCreateWithoutCreatorInput, TicketUncheckedCreateWithoutCreatorInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCreatorInput, TicketUncheckedUpdateWithoutCreatorInput>
  }

  export type TicketUpdateManyWithWhereWithoutCreatorInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: IntFilter<"Ticket"> | number
    ticket_number?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    priority?: EnumPriorityFilter<"Ticket"> | $Enums.Priority
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    category_id?: IntFilter<"Ticket"> | number
    subcategory_id?: IntNullableFilter<"Ticket"> | number | null
    client_id?: IntFilter<"Ticket"> | number
    created_by?: IntFilter<"Ticket"> | number
    assigned_to?: IntNullableFilter<"Ticket"> | number | null
    due_date?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    resolution_time?: IntNullableFilter<"Ticket"> | number | null
    satisfaction_rating?: IntNullableFilter<"Ticket"> | number | null
    created_at?: DateTimeFilter<"Ticket"> | Date | string
    modified_at?: DateTimeFilter<"Ticket"> | Date | string
    closed_at?: DateTimeNullableFilter<"Ticket"> | Date | string | null
  }

  export type TicketUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssigneeInput, TicketUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TicketCreateWithoutAssigneeInput, TicketUncheckedCreateWithoutAssigneeInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssigneeInput, TicketUncheckedUpdateWithoutAssigneeInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssigneeInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    ticket_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    is_internal?: BoolFilter<"Comment"> | boolean
    created_at?: DateTimeFilter<"Comment"> | Date | string
    modified_at?: DateTimeFilter<"Comment"> | Date | string
  }

  export type TicketAssignmentUpsertWithWhereUniqueWithoutAssigned_by_userInput = {
    where: TicketAssignmentWhereUniqueInput
    update: XOR<TicketAssignmentUpdateWithoutAssigned_by_userInput, TicketAssignmentUncheckedUpdateWithoutAssigned_by_userInput>
    create: XOR<TicketAssignmentCreateWithoutAssigned_by_userInput, TicketAssignmentUncheckedCreateWithoutAssigned_by_userInput>
  }

  export type TicketAssignmentUpdateWithWhereUniqueWithoutAssigned_by_userInput = {
    where: TicketAssignmentWhereUniqueInput
    data: XOR<TicketAssignmentUpdateWithoutAssigned_by_userInput, TicketAssignmentUncheckedUpdateWithoutAssigned_by_userInput>
  }

  export type TicketAssignmentUpdateManyWithWhereWithoutAssigned_by_userInput = {
    where: TicketAssignmentScalarWhereInput
    data: XOR<TicketAssignmentUpdateManyMutationInput, TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userInput>
  }

  export type TicketAssignmentScalarWhereInput = {
    AND?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
    OR?: TicketAssignmentScalarWhereInput[]
    NOT?: TicketAssignmentScalarWhereInput | TicketAssignmentScalarWhereInput[]
    id?: IntFilter<"TicketAssignment"> | number
    ticket_id?: IntFilter<"TicketAssignment"> | number
    agent_id?: IntFilter<"TicketAssignment"> | number
    assigned_by?: IntFilter<"TicketAssignment"> | number
    assigned_at?: DateTimeFilter<"TicketAssignment"> | Date | string
    unassigned_at?: DateTimeNullableFilter<"TicketAssignment"> | Date | string | null
  }

  export type TicketHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketHistoryWhereUniqueInput
    update: XOR<TicketHistoryUpdateWithoutUserInput, TicketHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<TicketHistoryCreateWithoutUserInput, TicketHistoryUncheckedCreateWithoutUserInput>
  }

  export type TicketHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketHistoryWhereUniqueInput
    data: XOR<TicketHistoryUpdateWithoutUserInput, TicketHistoryUncheckedUpdateWithoutUserInput>
  }

  export type TicketHistoryUpdateManyWithWhereWithoutUserInput = {
    where: TicketHistoryScalarWhereInput
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketHistoryScalarWhereInput = {
    AND?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
    OR?: TicketHistoryScalarWhereInput[]
    NOT?: TicketHistoryScalarWhereInput | TicketHistoryScalarWhereInput[]
    id?: IntFilter<"TicketHistory"> | number
    ticket_id?: IntFilter<"TicketHistory"> | number
    field_name?: StringFilter<"TicketHistory"> | string
    old_value?: StringNullableFilter<"TicketHistory"> | string | null
    new_value?: StringNullableFilter<"TicketHistory"> | string | null
    changed_by?: IntFilter<"TicketHistory"> | number
    created_at?: DateTimeFilter<"TicketHistory"> | Date | string
  }

  export type UserCreateWithoutAgentInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
  }

  export type TicketAssignmentCreateWithoutAgentInput = {
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
    ticket: TicketCreateNestedOneWithoutTicket_assignmentsInput
    assigned_by_user: UserCreateNestedOneWithoutTicket_assignmentsInput
  }

  export type TicketAssignmentUncheckedCreateWithoutAgentInput = {
    id?: number
    ticket_id: number
    assigned_by: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketAssignmentCreateOrConnectWithoutAgentInput = {
    where: TicketAssignmentWhereUniqueInput
    create: XOR<TicketAssignmentCreateWithoutAgentInput, TicketAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type TicketAssignmentCreateManyAgentInputEnvelope = {
    data: TicketAssignmentCreateManyAgentInput | TicketAssignmentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgentInput = {
    update: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
  }

  export type UserUpdateWithoutAgentInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketAssignmentUpsertWithWhereUniqueWithoutAgentInput = {
    where: TicketAssignmentWhereUniqueInput
    update: XOR<TicketAssignmentUpdateWithoutAgentInput, TicketAssignmentUncheckedUpdateWithoutAgentInput>
    create: XOR<TicketAssignmentCreateWithoutAgentInput, TicketAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type TicketAssignmentUpdateWithWhereUniqueWithoutAgentInput = {
    where: TicketAssignmentWhereUniqueInput
    data: XOR<TicketAssignmentUpdateWithoutAgentInput, TicketAssignmentUncheckedUpdateWithoutAgentInput>
  }

  export type TicketAssignmentUpdateManyWithWhereWithoutAgentInput = {
    where: TicketAssignmentScalarWhereInput
    data: XOR<TicketAssignmentUpdateManyMutationInput, TicketAssignmentUncheckedUpdateManyWithoutAgentInput>
  }

  export type UserCreateWithoutClientInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type TicketCreateWithoutClientInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutClientInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutClientInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketCreateManyClientInputEnvelope = {
    data: TicketCreateManyClientInput | TicketCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
  }

  export type TicketUpdateManyWithWhereWithoutClientInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutClientInput>
  }

  export type TicketCreateWithoutCategoryInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutCategoryInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutCategoryInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput>
  }

  export type TicketCreateManyCategoryInputEnvelope = {
    data: TicketCreateManyCategoryInput | TicketCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubcategoryCreateWithoutCategoryInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryCreateManyCategoryInputEnvelope = {
    data: SubcategoryCreateManyCategoryInput | SubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ResponseTemplateCreateWithoutCategoryInput = {
    name: string
    subject: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ResponseTemplateUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    subject: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ResponseTemplateCreateOrConnectWithoutCategoryInput = {
    where: ResponseTemplateWhereUniqueInput
    create: XOR<ResponseTemplateCreateWithoutCategoryInput, ResponseTemplateUncheckedCreateWithoutCategoryInput>
  }

  export type ResponseTemplateCreateManyCategoryInputEnvelope = {
    data: ResponseTemplateCreateManyCategoryInput | ResponseTemplateCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TicketUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCategoryInput, TicketUncheckedUpdateWithoutCategoryInput>
    create: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCategoryInput, TicketUncheckedUpdateWithoutCategoryInput>
  }

  export type TicketUpdateManyWithWhereWithoutCategoryInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    update: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    data: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubcategoryScalarWhereInput
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryScalarWhereInput = {
    AND?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    OR?: SubcategoryScalarWhereInput[]
    NOT?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    id?: IntFilter<"Subcategory"> | number
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    category_id?: IntFilter<"Subcategory"> | number
    is_active?: BoolFilter<"Subcategory"> | boolean
    created_at?: DateTimeFilter<"Subcategory"> | Date | string
    modified_at?: DateTimeFilter<"Subcategory"> | Date | string
  }

  export type ResponseTemplateUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ResponseTemplateWhereUniqueInput
    update: XOR<ResponseTemplateUpdateWithoutCategoryInput, ResponseTemplateUncheckedUpdateWithoutCategoryInput>
    create: XOR<ResponseTemplateCreateWithoutCategoryInput, ResponseTemplateUncheckedCreateWithoutCategoryInput>
  }

  export type ResponseTemplateUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ResponseTemplateWhereUniqueInput
    data: XOR<ResponseTemplateUpdateWithoutCategoryInput, ResponseTemplateUncheckedUpdateWithoutCategoryInput>
  }

  export type ResponseTemplateUpdateManyWithWhereWithoutCategoryInput = {
    where: ResponseTemplateScalarWhereInput
    data: XOR<ResponseTemplateUpdateManyMutationInput, ResponseTemplateUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ResponseTemplateScalarWhereInput = {
    AND?: ResponseTemplateScalarWhereInput | ResponseTemplateScalarWhereInput[]
    OR?: ResponseTemplateScalarWhereInput[]
    NOT?: ResponseTemplateScalarWhereInput | ResponseTemplateScalarWhereInput[]
    id?: IntFilter<"ResponseTemplate"> | number
    name?: StringFilter<"ResponseTemplate"> | string
    subject?: StringFilter<"ResponseTemplate"> | string
    content?: StringFilter<"ResponseTemplate"> | string
    category_id?: IntNullableFilter<"ResponseTemplate"> | number | null
    is_active?: BoolFilter<"ResponseTemplate"> | boolean
    created_at?: DateTimeFilter<"ResponseTemplate"> | Date | string
    modified_at?: DateTimeFilter<"ResponseTemplate"> | Date | string
  }

  export type CategoryCreateWithoutSubcategoriesInput = {
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketCreateNestedManyWithoutCategoryInput
    response_templates?: ResponseTemplateCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutCategoryInput
    response_templates?: ResponseTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type TicketCreateWithoutSubcategoryInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutSubcategoryInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutSubcategoryInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSubcategoryInput, TicketUncheckedCreateWithoutSubcategoryInput>
  }

  export type TicketCreateManySubcategoryInputEnvelope = {
    data: TicketCreateManySubcategoryInput | TicketCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CategoryUpdateWithoutSubcategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutCategoryNestedInput
    response_templates?: ResponseTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutCategoryNestedInput
    response_templates?: ResponseTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutSubcategoryInput, TicketUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<TicketCreateWithoutSubcategoryInput, TicketUncheckedCreateWithoutSubcategoryInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutSubcategoryInput, TicketUncheckedUpdateWithoutSubcategoryInput>
  }

  export type TicketUpdateManyWithWhereWithoutSubcategoryInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type CategoryCreateWithoutTicketsInput = {
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    response_templates?: ResponseTemplateCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    response_templates?: ResponseTemplateUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTicketsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTicketsInput, CategoryUncheckedCreateWithoutTicketsInput>
  }

  export type SubcategoryCreateWithoutTicketsInput = {
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    description?: string | null
    category_id: number
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type SubcategoryCreateOrConnectWithoutTicketsInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutTicketsInput, SubcategoryUncheckedCreateWithoutTicketsInput>
  }

  export type ClientCreateWithoutTicketsInput = {
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
    user: UserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTicketsInput = {
    id?: number
    user_id: number
    company?: string | null
    client_type?: $Enums.ClientType
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ClientCreateOrConnectWithoutTicketsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTickets_createdInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTickets_createdInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTickets_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTickets_createdInput, UserUncheckedCreateWithoutTickets_createdInput>
  }

  export type UserCreateWithoutTickets_assignedInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTickets_assignedInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTickets_assignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTickets_assignedInput, UserUncheckedCreateWithoutTickets_assignedInput>
  }

  export type CommentCreateWithoutTicketInput = {
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    user: UserCreateNestedOneWithoutTicket_commentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutTicketInput = {
    id?: number
    user_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutTicketInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTicketInput, CommentUncheckedCreateWithoutTicketInput>
  }

  export type CommentCreateManyTicketInputEnvelope = {
    data: CommentCreateManyTicketInput | CommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutTicketInput = {
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    created_at?: Date | string
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutTicketInput = {
    id?: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    comment_id?: number | null
    created_at?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutTicketInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutTicketInput, AttachmentUncheckedCreateWithoutTicketInput>
  }

  export type AttachmentCreateManyTicketInputEnvelope = {
    data: AttachmentCreateManyTicketInput | AttachmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketHistoryCreateWithoutTicketInput = {
    field_name: string
    old_value?: string | null
    new_value?: string | null
    created_at?: Date | string
    user: UserCreateNestedOneWithoutTicket_historyInput
  }

  export type TicketHistoryUncheckedCreateWithoutTicketInput = {
    id?: number
    field_name: string
    old_value?: string | null
    new_value?: string | null
    changed_by: number
    created_at?: Date | string
  }

  export type TicketHistoryCreateOrConnectWithoutTicketInput = {
    where: TicketHistoryWhereUniqueInput
    create: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput>
  }

  export type TicketHistoryCreateManyTicketInputEnvelope = {
    data: TicketHistoryCreateManyTicketInput | TicketHistoryCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketAssignmentCreateWithoutTicketInput = {
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
    agent: AgentCreateNestedOneWithoutTicket_assignmentsInput
    assigned_by_user: UserCreateNestedOneWithoutTicket_assignmentsInput
  }

  export type TicketAssignmentUncheckedCreateWithoutTicketInput = {
    id?: number
    agent_id: number
    assigned_by: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketAssignmentCreateOrConnectWithoutTicketInput = {
    where: TicketAssignmentWhereUniqueInput
    create: XOR<TicketAssignmentCreateWithoutTicketInput, TicketAssignmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAssignmentCreateManyTicketInputEnvelope = {
    data: TicketAssignmentCreateManyTicketInput | TicketAssignmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutTicketsInput = {
    update: XOR<CategoryUpdateWithoutTicketsInput, CategoryUncheckedUpdateWithoutTicketsInput>
    create: XOR<CategoryCreateWithoutTicketsInput, CategoryUncheckedCreateWithoutTicketsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTicketsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTicketsInput, CategoryUncheckedUpdateWithoutTicketsInput>
  }

  export type CategoryUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    response_templates?: ResponseTemplateUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    response_templates?: ResponseTemplateUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SubcategoryUpsertWithoutTicketsInput = {
    update: XOR<SubcategoryUpdateWithoutTicketsInput, SubcategoryUncheckedUpdateWithoutTicketsInput>
    create: XOR<SubcategoryCreateWithoutTicketsInput, SubcategoryUncheckedCreateWithoutTicketsInput>
    where?: SubcategoryWhereInput
  }

  export type SubcategoryUpdateToOneWithWhereWithoutTicketsInput = {
    where?: SubcategoryWhereInput
    data: XOR<SubcategoryUpdateWithoutTicketsInput, SubcategoryUncheckedUpdateWithoutTicketsInput>
  }

  export type SubcategoryUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpsertWithoutTicketsInput = {
    update: XOR<ClientUpdateWithoutTicketsInput, ClientUncheckedUpdateWithoutTicketsInput>
    create: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTicketsInput, ClientUncheckedUpdateWithoutTicketsInput>
  }

  export type ClientUpdateWithoutTicketsInput = {
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company?: NullableStringFieldUpdateOperationsInput | string | null
    client_type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTickets_createdInput = {
    update: XOR<UserUpdateWithoutTickets_createdInput, UserUncheckedUpdateWithoutTickets_createdInput>
    create: XOR<UserCreateWithoutTickets_createdInput, UserUncheckedCreateWithoutTickets_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTickets_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTickets_createdInput, UserUncheckedUpdateWithoutTickets_createdInput>
  }

  export type UserUpdateWithoutTickets_createdInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTickets_createdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutTickets_assignedInput = {
    update: XOR<UserUpdateWithoutTickets_assignedInput, UserUncheckedUpdateWithoutTickets_assignedInput>
    create: XOR<UserCreateWithoutTickets_assignedInput, UserUncheckedCreateWithoutTickets_assignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTickets_assignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTickets_assignedInput, UserUncheckedUpdateWithoutTickets_assignedInput>
  }

  export type UserUpdateWithoutTickets_assignedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTickets_assignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTicketInput, CommentUncheckedUpdateWithoutTicketInput>
    create: XOR<CommentCreateWithoutTicketInput, CommentUncheckedCreateWithoutTicketInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTicketInput, CommentUncheckedUpdateWithoutTicketInput>
  }

  export type CommentUpdateManyWithWhereWithoutTicketInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutTicketInput, AttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<AttachmentCreateWithoutTicketInput, AttachmentUncheckedCreateWithoutTicketInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutTicketInput, AttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: IntFilter<"Attachment"> | number
    filename?: StringFilter<"Attachment"> | string
    original_name?: StringFilter<"Attachment"> | string
    file_path?: StringFilter<"Attachment"> | string
    file_size?: IntFilter<"Attachment"> | number
    mime_type?: StringFilter<"Attachment"> | string
    ticket_id?: IntNullableFilter<"Attachment"> | number | null
    comment_id?: IntNullableFilter<"Attachment"> | number | null
    created_at?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type TicketHistoryUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketHistoryWhereUniqueInput
    update: XOR<TicketHistoryUpdateWithoutTicketInput, TicketHistoryUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketHistoryCreateWithoutTicketInput, TicketHistoryUncheckedCreateWithoutTicketInput>
  }

  export type TicketHistoryUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketHistoryWhereUniqueInput
    data: XOR<TicketHistoryUpdateWithoutTicketInput, TicketHistoryUncheckedUpdateWithoutTicketInput>
  }

  export type TicketHistoryUpdateManyWithWhereWithoutTicketInput = {
    where: TicketHistoryScalarWhereInput
    data: XOR<TicketHistoryUpdateManyMutationInput, TicketHistoryUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketAssignmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAssignmentWhereUniqueInput
    update: XOR<TicketAssignmentUpdateWithoutTicketInput, TicketAssignmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAssignmentCreateWithoutTicketInput, TicketAssignmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAssignmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAssignmentWhereUniqueInput
    data: XOR<TicketAssignmentUpdateWithoutTicketInput, TicketAssignmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAssignmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAssignmentScalarWhereInput
    data: XOR<TicketAssignmentUpdateManyMutationInput, TicketAssignmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCreateWithoutCommentsInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutCommentsInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutCommentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTicket_commentsInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicket_commentsInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicket_commentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicket_commentsInput, UserUncheckedCreateWithoutTicket_commentsInput>
  }

  export type AttachmentCreateWithoutCommentInput = {
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    created_at?: Date | string
    ticket?: TicketCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutCommentInput = {
    id?: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    ticket_id?: number | null
    created_at?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput>
  }

  export type AttachmentCreateManyCommentInputEnvelope = {
    data: AttachmentCreateManyCommentInput | AttachmentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type TicketUpsertWithoutCommentsInput = {
    update: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type TicketUpdateWithoutCommentsInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicket_commentsInput = {
    update: XOR<UserUpdateWithoutTicket_commentsInput, UserUncheckedUpdateWithoutTicket_commentsInput>
    create: XOR<UserCreateWithoutTicket_commentsInput, UserUncheckedCreateWithoutTicket_commentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicket_commentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicket_commentsInput, UserUncheckedUpdateWithoutTicket_commentsInput>
  }

  export type UserUpdateWithoutTicket_commentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicket_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutCommentInput, AttachmentUncheckedUpdateWithoutCommentInput>
    create: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutCommentInput, AttachmentUncheckedUpdateWithoutCommentInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutCommentInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutCommentInput>
  }

  export type TicketCreateWithoutAttachmentsInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAttachmentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
  }

  export type CommentCreateWithoutAttachmentsInput = {
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTicket_commentsInput
  }

  export type CommentUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    ticket_id: number
    user_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type CommentCreateOrConnectWithoutAttachmentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
  }

  export type TicketUpsertWithoutAttachmentsInput = {
    update: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketUpdateWithoutAttachmentsInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type CommentUpsertWithoutAttachmentsInput = {
    update: XOR<CommentUpdateWithoutAttachmentsInput, CommentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutAttachmentsInput, CommentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommentUpdateWithoutAttachmentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTicket_commentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateWithoutTicket_historyInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicket_historyInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicket_historyInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicket_historyInput, TicketUncheckedCreateWithoutTicket_historyInput>
  }

  export type UserCreateWithoutTicket_historyInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentCreateNestedManyWithoutAssigned_by_userInput
  }

  export type UserUncheckedCreateWithoutTicket_historyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_assignments?: TicketAssignmentUncheckedCreateNestedManyWithoutAssigned_by_userInput
  }

  export type UserCreateOrConnectWithoutTicket_historyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicket_historyInput, UserUncheckedCreateWithoutTicket_historyInput>
  }

  export type TicketUpsertWithoutTicket_historyInput = {
    update: XOR<TicketUpdateWithoutTicket_historyInput, TicketUncheckedUpdateWithoutTicket_historyInput>
    create: XOR<TicketCreateWithoutTicket_historyInput, TicketUncheckedCreateWithoutTicket_historyInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicket_historyInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicket_historyInput, TicketUncheckedUpdateWithoutTicket_historyInput>
  }

  export type TicketUpdateWithoutTicket_historyInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicket_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicket_historyInput = {
    update: XOR<UserUpdateWithoutTicket_historyInput, UserUncheckedUpdateWithoutTicket_historyInput>
    create: XOR<UserCreateWithoutTicket_historyInput, UserUncheckedCreateWithoutTicket_historyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicket_historyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicket_historyInput, UserUncheckedUpdateWithoutTicket_historyInput>
  }

  export type UserUpdateWithoutTicket_historyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutAssigned_by_userNestedInput
  }

  export type UserUncheckedUpdateWithoutTicket_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userNestedInput
  }

  export type TicketCreateWithoutTicket_assignmentsInput = {
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    category: CategoryCreateNestedOneWithoutTicketsInput
    subcategory?: SubcategoryCreateNestedOneWithoutTicketsInput
    client: ClientCreateNestedOneWithoutTicketsInput
    creator: UserCreateNestedOneWithoutTickets_createdInput
    assignee?: UserCreateNestedOneWithoutTickets_assignedInput
    comments?: CommentCreateNestedManyWithoutTicketInput
    attachments?: AttachmentCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicket_assignmentsInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTicketInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTicketInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicket_assignmentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicket_assignmentsInput, TicketUncheckedCreateWithoutTicket_assignmentsInput>
  }

  export type AgentCreateWithoutTicket_assignmentsInput = {
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTicket_assignmentsInput = {
    id?: number
    user_id: number
    employee_id: string
    department?: string | null
    skills?: AgentCreateskillsInput | string[]
    max_tickets?: number
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type AgentCreateOrConnectWithoutTicket_assignmentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTicket_assignmentsInput, AgentUncheckedCreateWithoutTicket_assignmentsInput>
  }

  export type UserCreateWithoutTicket_assignmentsInput = {
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentCreateNestedOneWithoutUserInput
    client?: ClientCreateNestedOneWithoutUserInput
    tickets_created?: TicketCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentCreateNestedManyWithoutUserInput
    ticket_history?: TicketHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicket_assignmentsInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    created_at?: Date | string
    modified_at?: Date | string
    role: $Enums.Role
    hashed_password: string
    is_active?: boolean
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    tickets_created?: TicketUncheckedCreateNestedManyWithoutCreatorInput
    tickets_assigned?: TicketUncheckedCreateNestedManyWithoutAssigneeInput
    ticket_comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ticket_history?: TicketHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicket_assignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicket_assignmentsInput, UserUncheckedCreateWithoutTicket_assignmentsInput>
  }

  export type TicketUpsertWithoutTicket_assignmentsInput = {
    update: XOR<TicketUpdateWithoutTicket_assignmentsInput, TicketUncheckedUpdateWithoutTicket_assignmentsInput>
    create: XOR<TicketCreateWithoutTicket_assignmentsInput, TicketUncheckedCreateWithoutTicket_assignmentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicket_assignmentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicket_assignmentsInput, TicketUncheckedUpdateWithoutTicket_assignmentsInput>
  }

  export type TicketUpdateWithoutTicket_assignmentsInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicket_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type AgentUpsertWithoutTicket_assignmentsInput = {
    update: XOR<AgentUpdateWithoutTicket_assignmentsInput, AgentUncheckedUpdateWithoutTicket_assignmentsInput>
    create: XOR<AgentCreateWithoutTicket_assignmentsInput, AgentUncheckedCreateWithoutTicket_assignmentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTicket_assignmentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTicket_assignmentsInput, AgentUncheckedUpdateWithoutTicket_assignmentsInput>
  }

  export type AgentUpdateWithoutTicket_assignmentsInput = {
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTicket_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    employee_id?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: AgentUpdateskillsInput | string[]
    max_tickets?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTicket_assignmentsInput = {
    update: XOR<UserUpdateWithoutTicket_assignmentsInput, UserUncheckedUpdateWithoutTicket_assignmentsInput>
    create: XOR<UserCreateWithoutTicket_assignmentsInput, UserUncheckedCreateWithoutTicket_assignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicket_assignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicket_assignmentsInput, UserUncheckedUpdateWithoutTicket_assignmentsInput>
  }

  export type UserUpdateWithoutTicket_assignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUpdateOneWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUpdateManyWithoutUserNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicket_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    tickets_created?: TicketUncheckedUpdateManyWithoutCreatorNestedInput
    tickets_assigned?: TicketUncheckedUpdateManyWithoutAssigneeNestedInput
    ticket_comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryCreateWithoutResponse_templatesInput = {
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutResponse_templatesInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    icon?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutResponse_templatesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutResponse_templatesInput, CategoryUncheckedCreateWithoutResponse_templatesInput>
  }

  export type CategoryUpsertWithoutResponse_templatesInput = {
    update: XOR<CategoryUpdateWithoutResponse_templatesInput, CategoryUncheckedUpdateWithoutResponse_templatesInput>
    create: XOR<CategoryCreateWithoutResponse_templatesInput, CategoryUncheckedCreateWithoutResponse_templatesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutResponse_templatesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutResponse_templatesInput, CategoryUncheckedUpdateWithoutResponse_templatesInput>
  }

  export type CategoryUpdateWithoutResponse_templatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutResponse_templatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TicketCreateManyCreatorInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
  }

  export type TicketCreateManyAssigneeInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    client_id: number
    created_by: number
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
  }

  export type CommentCreateManyUserInput = {
    id?: number
    ticket_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type TicketAssignmentCreateManyAssigned_by_userInput = {
    id?: number
    ticket_id: number
    agent_id: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketHistoryCreateManyUserInput = {
    id?: number
    ticket_id: number
    field_name: string
    old_value?: string | null
    new_value?: string | null
    created_at?: Date | string
  }

  export type TicketUpdateWithoutCreatorInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketUpdateWithoutAssigneeInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAssignmentUpdateWithoutAssigned_by_userInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ticket?: TicketUpdateOneRequiredWithoutTicket_assignmentsNestedInput
    agent?: AgentUpdateOneRequiredWithoutTicket_assignmentsNestedInput
  }

  export type TicketAssignmentUncheckedUpdateWithoutAssigned_by_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    agent_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAssignmentUncheckedUpdateManyWithoutAssigned_by_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    agent_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketHistoryUpdateWithoutUserInput = {
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicket_historyNestedInput
  }

  export type TicketHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAssignmentCreateManyAgentInput = {
    id?: number
    ticket_id: number
    assigned_by: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type TicketAssignmentUpdateWithoutAgentInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ticket?: TicketUpdateOneRequiredWithoutTicket_assignmentsNestedInput
    assigned_by_user?: UserUpdateOneRequiredWithoutTicket_assignmentsNestedInput
  }

  export type TicketAssignmentUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAssignmentUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketCreateManyClientInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    subcategory_id?: number | null
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
  }

  export type TicketUpdateWithoutClientInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketCreateManyCategoryInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    subcategory_id?: number | null
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
  }

  export type SubcategoryCreateManyCategoryInput = {
    id?: number
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type ResponseTemplateCreateManyCategoryInput = {
    id?: number
    name: string
    subject: string
    content: string
    is_active?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type TicketUpdateWithoutCategoryInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subcategory?: SubcategoryUpdateOneWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subcategory_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubcategoryUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseTemplateUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseTemplateUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseTemplateUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManySubcategoryInput = {
    id?: number
    ticket_number: string
    title: string
    description: string
    priority?: $Enums.Priority
    status?: $Enums.TicketStatus
    category_id: number
    client_id: number
    created_by: number
    assigned_to?: number | null
    due_date?: Date | string | null
    resolution_time?: number | null
    satisfaction_rating?: number | null
    created_at?: Date | string
    modified_at?: Date | string
    closed_at?: Date | string | null
  }

  export type TicketUpdateWithoutSubcategoryInput = {
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutTicketsNestedInput
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
    creator?: UserUpdateOneRequiredWithoutTickets_createdNestedInput
    assignee?: UserUpdateOneWithoutTickets_assignedNestedInput
    comments?: CommentUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutSubcategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTicketNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTicketNestedInput
    ticket_history?: TicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ticket_assignments?: TicketAssignmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    category_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    assigned_to?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution_time?: NullableIntFieldUpdateOperationsInput | number | null
    satisfaction_rating?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyTicketInput = {
    id?: number
    user_id: number
    content: string
    is_internal?: boolean
    created_at?: Date | string
    modified_at?: Date | string
  }

  export type AttachmentCreateManyTicketInput = {
    id?: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    comment_id?: number | null
    created_at?: Date | string
  }

  export type TicketHistoryCreateManyTicketInput = {
    id?: number
    field_name: string
    old_value?: string | null
    new_value?: string | null
    changed_by: number
    created_at?: Date | string
  }

  export type TicketAssignmentCreateManyTicketInput = {
    id?: number
    agent_id: number
    assigned_by: number
    assigned_at?: Date | string
    unassigned_at?: Date | string | null
  }

  export type CommentUpdateWithoutTicketInput = {
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicket_commentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutTicketInput = {
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketHistoryUpdateWithoutTicketInput = {
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicket_historyNestedInput
  }

  export type TicketHistoryUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    changed_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketHistoryUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    changed_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAssignmentUpdateWithoutTicketInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: AgentUpdateOneRequiredWithoutTicket_assignmentsNestedInput
    assigned_by_user?: UserUpdateOneRequiredWithoutTicket_assignmentsNestedInput
  }

  export type TicketAssignmentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    agent_id?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAssignmentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    agent_id?: IntFieldUpdateOperationsInput | number
    assigned_by?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unassigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentCreateManyCommentInput = {
    id?: number
    filename: string
    original_name: string
    file_path: string
    file_size: number
    mime_type: string
    ticket_id?: number | null
    created_at?: Date | string
  }

  export type AttachmentUpdateWithoutCommentInput = {
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: IntFieldUpdateOperationsInput | number
    mime_type?: StringFieldUpdateOperationsInput | string
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}